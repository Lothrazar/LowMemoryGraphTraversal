
\documentclass[12pt]{article} 
 
 \usepackage{color}

\usepackage{amsfonts,amsthm,amssymb,amsmath} 
\usepackage[pdftex]{graphicx} 
\DeclareGraphicsRule{.pdftex}{pdf}{.pdftex}{} 
\usepackage{setspace} 
\usepackage{url}
\usepackage{verbatim} 
\usepackage{algorithmic} 
\usepackage{algorithm} 
\usepackage{fancyhdr} 
\usepackage{mathtext} 
\usepackage{mathrsfs} 
\usepackage{amsfonts} 


%COMPILE AT SCHOOL OR INSTALL PACKAGE
%\usepackage[hang,font=small,labelfont=bf,textfont=it]{caption}

\pagestyle{fancy} 



\lhead{Sam Bassett} 
\rhead{\today} 

\setlength{\headheight}{15pt}
\setlength{\topmargin}{.25in} 
\setlength{\leftmargin}{1.25cm} 
%\setlength{\evensidemargin}{3.17cm} 
%\setlength{\oddsidemargin}{3.17cm}  
%\setlength{\textheight}{8.25in} 
\setlength{\textwidth}{6in} 
\setlength{\footskip}{.4in} 
\setlength{\headwidth}{\textwidth}  
 
%\title{blah blah} 
\author{Samson Bassett} 
 


\newcommand{\procedure}{\textbf{procedure}}
\newcommand{\mintail}{\textbf{mintail}}
%\newcommand{\twopath}{\textbf{twopath}}
\newcommand{\rev}{\textbf{rev}}
\newcommand{\suc}{\textbf{succ}}
\newcommand{\pred}{\textbf{pred}}
\newcommand{\prev}{\textbf{prev}}
\newcommand{\next}{\textbf{next}}
\newcommand{\nextright}{\textbf{nextright}}
\newcommand{\cwalk}{\textbf{cwalk}}
\newcommand{\entry}{\textbf{entry}}
\newcommand{\parent}{\textbf{parent}}
\newcommand{\ismin}{\textbf{ismin}}
\newcommand{\head}{\textbf{head}}
\newcommand{\tail}{\textbf{tail}}
%\newcommand{\loc}{\textbf{loc}}
%\newcommand{\locv}{\textbf{locv}}
%\newcommand{\drop}{\textbf{drop}}
%\newcommand{\bblank}{\textbf{blank}}
%\newcommand{\virtual}{\textbf{virtual}}

\newcommand{\key}{\textbf{key}}
\newcommand{\closer}{\textbf{smaller}}
\newcommand{\xcor}{\textbf{x}}
\newcommand{\ycor}{\textbf{y}}
\newcommand{\zcor}{\textbf{z}}
\newcommand{\sx}{\textbf{sx}}
\newcommand{\sy}{\textbf{sy}}
\newcommand{\sz}{\textbf{sz}}
%\newcommand{\entryport}{\textbf{ entryport}
%\newcommand{\fillempty}{\textbf{ fillempty}









\newcommand{\degr}{d} 
\newtheorem{theorem}{Theorem}[section] 
\newtheorem{lemma}[theorem]{Lemma} 
\newtheorem{obs}[theorem]{Observation} 
\newtheorem{proposition}[theorem]{Proposition} 
\newtheorem{definition}[theorem]{Definition}
\newtheorem{corollary}[theorem]{Corollary} 
%\newtheorem{procedure}[theorem]{procedure} 
 
\begin{document} 

%\begin{centering}
%test

%\end{centering}




\newpage
 \tableofcontents
\newpage
\listoffigures
\newpage


\section{Introduction} 
 
%** edit and update, include references to geometric traversal, make sure there is less redundancy in the indroduction of that subsection,
%*add mention of extension of periodic traversal to general graphs - after it is written.

%exploration vs traversal vs hamiltonian cycle.  use citations at the bottom.

%unlabeled: bfs, dfs, random walk, geometric: planar, quasiplanar

%unlabelled: broadcasting periodic: 2n-2, 10n, 4n-O1 conjecture, 4n, 3.75n. then our result.

\subsection{Motivation and Background}
In this thesis we consider the \emph{graph traversal} problem; that is, finding a route on a graph that visits every vertex after 
starting from an arbitrary vertex, that typically halts at the starting vertex.  One possible solution 
to this problem is a \emph{universal traversal sequence}, which 
is a walk of the graph that contains every vertex.  
This problem is stronger than the related problem of \emph{route discovery}, or $st$-\emph{connectivity}, 
which wants to find a route between two given vertices $s$ and $t$.  
Clearly, a solution to the graph traversal problem will guarantee a route between any two vertices, although it cannot 
ensure the shortest path.  We assume that the entire structure of the graph is not known, and only local 
information can be used.  




%Of course, the running time of 
%any traversal algorithm on a graph with $n$ vertices has a trivial lower bound of 
%$O(n)$, since every vertex must be visited at least once.  %This tradeoff has 
%been investigated extensively.  

%For our purposes we only consider finite, simple graphs.  




%In terms of computational complexity, we can investigate the tradeoff between the running time of an algorithm, and 
%the memory, or space, that it uses.  


%In \cite{BF}, it was shown that any graph can be traversed in space $S$ 
%and time $T$, such that $ST \le mn (\log n)^{K}$, where $K$ is a constant.  
%This implies there is a spectrum of comprimises between memory and running time for this problem.  One 
%improvement to this would be a linear time algorithm that uses logarithmic space for general graphs.  

The model of computation used is 
typically some type of mobile agent, that starts at 
an initial vertex, and moves between adjacent vertices along edges according to the algorithm.  These agents are often formally modeled as some type of 
finite automaton.  The running time of a traversal algorithm is the number of times the mobile agent traverses an edge of the graph.  
Hence the running time of any traversal algorithm has the trivial lower bound of $O(n)$ for 
an $n$ vertex graph, since the mobile agent must visit every vertex at least once.  

Graph traversal problems 
have two important variations, based on whether or not the agent can distinguish between vertices of the graph.  We say that a 
graph is \emph{anonymous} if the mobile agent cannot distinguish between two arbitrary vertices.  This variation is 
also known as the \emph{exploration of an unknown} graph.  Otherwise the 
graph is assumed to have one unique label for each vertex, (that is readable by the mobile agent).  %The labels of these 
%non-anonymous graphs often represent the geometric iformation of the vertex in some coordinate system.  
If a graph 
is not anonymous, there is a trivial memory lower bound of $O(\log n)$, 
which is the memory required for $n$ binary labels.  Anonymous graphs have a trivial lower bound of $O(1)$ memory.  
If an algorithm for an anonymous graph uses $O(1)$ memory, we say it uses 
constant memory.  Similarly, if an algorithm for a non-anonymous graph uses $O(\log n)$ memory, we say it uses 
no extra memory.  In this thesis, we are interested in finding the fastest deterministic traversal algorithms that achieve these 
optimal memory requirements.  Often, (particularly in the third chapter), we identify a mobile agent with the algorithm it uses, and say the 
algorithm moves to a vertex, meaning the agent moves to that vertex.  


Graph traversal is an important problem in computational mathematics, since it can be used to model many routing search processes, 
as mentioned above.  Applications 
for this problem include wireless computing, where a set of vertices with connections between them represent an ad-hoc wireless network.  
The mobile devices represented by vertices in this setting perform various tasks such as route discovery.  Often these mobile 
devices have some sort of global positioning system (GPS), and hence the network can be modelled as a non-anonymous graph, where each 
vertex is labelled with its geometric coordinates.  For examples see \cite{BMSU}, \cite{KSU}, \cite{KWZZ}, \cite{KWZ}, \cite{PM}.  



\subsection{Definitions and Notation}

A finite simple graph $G$ is an ordered pair $G=(V,E)$, where $V$ is a finite 
set of vertices, and $E$ is a finite set of edges such that each edge is a two element subset of $V$.  We 
refer to finite simple graphs as just graphs.  
For an edge $e=\{u,v\}$ we simply write $e=uv$, and say that $e$ is incident 
to both $u$ and $v$.  The \emph{degree} of a vertex $v$, denoted $d(v)$, is the number of edges incident to $v$.  

A $uv$-\emph{walk} 
in a graph $G$ is an ordered sequence of vertices 
$u=v_0, v_1, \ldots, v_{k-1}, v_k=v$, such that $v_iv_{i+1}\in E$ for 
all $0 \le i \le k-1$; these are referred to as edges of the walk.  
The \emph{length} of this walk is $k$.  
The vertices $u$ and $v$ are the \emph{terminal} vertices of the $uv$-walk.  
If $u$ and $v$ are understood, we simply refer to this $uv$-walk 
as a walk.  Non-terminal vertices are called \emph{internal} vertices of the walk.    
A \emph{path} is a walk that does not allow 
the repetition of vertices.   If $P$ is a $uv$-path, and $s$ and $t$ are vertices of $P$, then the $st$-path 
containing only edges of $P$ is an $st$-\emph{subpath} of $P$, or simply a subpath of $P$.  We say that 
two distinct paths are \emph{internally disjoint} if they have no internal vertices in common.  
A \emph{closed walk} $C$ of $G$ is a $uv$-walk such that $u=v$.  A \emph{cycle} is a closed walk that does 
not allow the repetition of vertices.  
A cycle in $G$ that 
contains every vertex of $G$ exactly once is called a \emph{Hamiltonian cycle}.  A \emph{Hamiltonian walk} is 
a closed walk in $G$ that 
contains every vertex of $G$ at least once.
The \emph{distance} between two vertices $u$ and $v$ is the 
length of a shortest $uv$-path.  
The \emph{square} of a graph $G$, denoted $G^2$, 
is constructed by starting  
from $G$, and then adding an edge between each pair of vertices at distance two.  Clearly, $G$ is a subgraph of $G^2$.  

A \emph{vertex cut} of a graph $G$ is a set of vertices whose removal renders the resulting graph disconnected.  If 
a vertex cut contains only a single vertex $v$, we call $v$ a \emph{cut vertex} of $G$.  We say that 
the \emph{connectivity} of $G$ is $k$, or $G$ is $k$-\emph{connected}, if a minimal vertex cut 
of $G$ contains at least $k$ vertices.  Clearly, $G$ is $k$-connected if and only if for every pair of vertices $u$ and 
$v$ in $G$, there exist 
$k$ internally disojoint $uv$-paths.    

The \emph{symmetric orientation} of $G$, denoted $\vec{G}$, replaces each edge $uv$ of $G$ with the two 
\emph{arcs} $(u,v)$ and $(v,u)$.  
We say that $G$ is the \emph{underlying} graph of $\vec{G}$.  The degree of a vertex in $\vec{G}$ 
will still be considered 
as the degree in the underlying graph. 
For the arc $(u,v)$, we say that $u$ is the tail (vertex) of the arc, 
and $v$ is the head (vertex) of the arc.  We say that $(u,v)$ is an arc from $u$ to $v$.  
If $e=(u,v)$, the 
\emph{reverse} of $e$ is $e^{-1}=(v,u)$.  
A \emph{directed} $uv$-\emph{path} $P$ is an ordered sequence of vertices 
$u=v_0, v_1, \ldots, v_{k-1}, v_k=v$, without repetition, such that $(v_i,v_{i+1})$ is an arc for 
all $0 \le i \le k-1$.  The \emph{reverse} of the directed path $P$, denoted $P^{-1}$, is the 
directed path $v_k, v_{k-1}, \ldots, v_1,v_0$.  

%We can define a directed cycle in a similar way.  
%If $uv$ is an edge of the graph $G=(V,E)$, we assign an orientation to 
%$uv$ by replacing $G$ with $(V,E\backslash \{uv\},\{(u,v)\})$, which is now a mixed graph.  Similarly we can assign 
%%an orientation to any edge in a mixed graph.  It is often useful to identify an undirected graph $G$ with 
%its \emph{associated directed graph}, where each edge $uv$ is replaced by the two 
%arcs $(u,v)$ and $(v,u)$ (both are referred to simply as $G$).  
%If the orientation of an arc $(u,v)$ is not relevant, we sometimes refer to the arc as $uv$, 
%which is the corresponding edge of the underlying graph.  


A subgraph $F$ of $G$ is an \emph{induced} subgraph if, for any pair of vertices $x$, $y$ in $F$, 
$xy$ is an edge of $F$ if and only if $xy$ is an edge of $G$.  A graph $G$ that does not contain 
$F$ as an induced subgraph is $F$-\emph{free}.  If $F$ is a path of length $k$, we say that 
$G$ is $P_k$-free.  




If $S$ is a set of elements, we denote \emph{total order} on the elements of $S$ by $(S,\le)$, which is a 
relation that must satisfy the following properties.  
If $a,b\in S$, then either $a\le b$ or $b\le a$.  Furthermore if $a\le b$ and $b\le a$, then $a=b$.  If $a,b,c\in S$, and we know 
$a\le b$ and $b\le c$, it follows that $a<c$.  We say that $a<b$ if $a\le b$ and $a\ne b$.  

\begin{comment}
An \emph{alphabet} is a set of elements called characters.  A \emph{string} over the 
alphabet $\Sigma$ is a finite ordered collection of characters from $\Sigma$.  

A \emph{logical machine} is a mathematical construct that works in a 
similar way to a function, it takes specific input and computes output.  Logical 
machines are used in the computation of algorithms.  
%A \emph{finite state machine} or \emph{FSM} is a logical machine 
%that processes strings.  A FSM is a logical machine with limited memory; it has a set of potential states, but it 
%is only in one current state at each step of its computation.  It reads a string as input, and proceeds 
%to scan the string one symbol at each step.  The FSM cannot remember any of the string that has previously been computed.  
%At each step, the machine
%transitions to a new state based on the current state and the current 
%input symbol.  Once it reaches the end of the string, itS output 
%is to either \emph{accept} or \emph{reject} the string.  Formally, this computation is defined 
%as follows, in terms of sets and a \emph{transition function}.  


%\begin{definition}\label{def:fsm}
\noindent A \emph{finite state machine} $M$ is a 
five-tuple $M = (\Sigma,Q,q_0,\delta,F)$, where:
\begin{itemize}
\item $\Sigma$ is the input alphabet
\item $Q$ is a finite set of states
\item $q_0\in Q$ is the initial state 
\item $T : Q \times \Sigma \to Q$ is the transition function
\item $F \subseteq Q$ is the set of accepting states
\end{itemize}  
%\end{definition}

The execution of a finite state machine is as follows. 
Let $M$ be a finite state machine.  Let $x$ be a string of characters from $\Sigma$, i.e., 
$x=s_1 s_2 \cdots s_n$, where each $s_i \in \Sigma$.  Initially, $M$ is in 
state $q_0$ and it scans $s_1$.  
Then $M$ computes the transition function $\delta(q_0,s_1)=q_j$ and transitions to state $q_j$.  
This repeats until the end of the string is reached; after $M$ computes $\delta(q_a,s_n)=q_b$.    
If at the end of the string, the current state $q_b \in F$, 
then we say $M$ \emph{accepts} the string $x$, otherwise $M$ \emph{rejects} $x$.  



An \emph{alphabet} is a set of elements called characters.  A \emph{string} over the 
alphabet $\Sigma$ is a finite ordered collection of characters from $\Sigma$.  

A \emph{logical machine} is a mathematical construct that works in a 
similar way to a function, it takes specific input and computes an output character after each 
step of the computation. A specific logical machine is defined below.\\

%\begin{definition}\label{def:ma}
\noindent A \emph{Mealy Automata} $M$ is a 
five-tuple $M = (\Sigma,\Delta,Q,\alpha,T)$, where:
\begin{itemize}
\item $\Sigma$ is the input alphabet
\item $\Delta$ is the secondary alphabet
\item $Q$ is a finite set of states
\item $\alpha\in S$ is the initial state 
\item $T : Q \times \Sigma \to Q \times \Delta$ is the transition function
%\item $G : Q \times \Sigma \to \Delta$ is the output function
%\item $F \subseteq Q$ is the set of accepting states.
\end{itemize}  
%\end{definition}




A Mealy automata is a logical machine with limited memory; it has a set of potential states, but it 
is only in one current state at each step of its computation.  One \emph{step} of the machine 
is one computation of the \emph{transition function} $T$.  Initially, the machine is in state $\alpha$, and has some initial 
input $s$.  The transition function computes $T(\alpha,s)=(q,d)$, which means $M$ transitions into state $q$, and outputs 
the symbol $d$ from the secondary alphabet.  This output character $d$ is often used by the next 
step of the computation, and may not be saved as any sort of permanent output.  

\end{comment}

\subsection{Previous Results}


In anonymous graphs, the mobile agent needs some extra information to navigate the graph.  
We allow edges at an incident vertex to be distinguishable from one another; this is sometimes 
called a local orientation.  One way of encoding this information is to use port numbers, which were first proposed in \cite{DJSS}.  
At each vertex, we assign an ordering to all the 
edges incident to it, which is usually represented by integers between $1$ and the degree of the vertex, 
called a \emph{port number}.  When all vertices in 
a graph $G$ has these port numbers for its incident edges, we call this a local orientation of $G$.  


\begin{theorem}\label{it1}
\cite{B} No finite automaton can traverse all graphs if the local orientation is given by an adversary.  
\end{theorem}

%  
%This implies that a finite automata cannot successfully traverse a graph with arbitrarily assigned port numbers, and requires 
%some special assignment.  


Theorem \ref{it1} implies that graph traversal is impossible in this context.  
This seems to imply that either we need 
a mobile agent that uses a more powerful model of computation, 
or we need more to encode more information into the graph itself.  


One obvious way to make the model of computation more powerful is to use more than one mobile agent, 
that somehow cooperate and share information.  However, Theorem \ref{tr} shows that 
this by itself is not enough 
to traverse all graphs.  


\begin{theorem}\label{tr}
\cite{R} A finite team of finite automaton cannot traverse all planar cubic graphs.  
\end{theorem}



Another way to improve the model of computation is to allow the mobile 
agent the ability to drop and remove pebbles, (sometimes called mark bits), on the vertices it visits.  These pebbles are indistinguishable from 
one another, but it allows the agent to identify marked and unmarked vertices.  As long as only a constant number of pebbles are allowed, 
the solution still only requires $O(1)$ memory.  Another variation is to use more than one mobile agent (without pebbles) that work together 
to explore the graph.  Increasing the number of mobile agents seems to provide a more powerful model of computation, 
for example, using three mobile agents should be a more powerful model of computation than one agent and two pebbles.  The 
following theorems from \cite{BS} examine this relationship.  Also, one extra piece of information that is sometimes supposed to be known by the 
mobile agent, is an upper bound on the number of vertices in 
the graph; this information is surprisingly useful, as seen 
below.  Notice that results for directed graphs also apply to undirected graphs, by considering the 
symmetric orientation of the undirected graph.  




\begin{theorem}
\cite{CR} A finite JAG cannot traverse all graphs.  
\end{theorem}

\begin{theorem}\label{it1p5}
\cite{BS} Two mobile agents are sufficient to perform a graph traversal of an anonymous directed graph. 
\end{theorem}

So no more than two mobile agents are needed.  It turns out that this is strictly more powerful than one agent with a constant number of pebbles.  

\begin{theorem}\label{it1p6}
\cite{BS} One mobile agent with $O(1)$ pebbles are 
not sufficient efficiently traverse an anonymous directed graph, if the agent does not 
know an upper bound on the number of vertices of the graph. 
\end{theorem}



The authors of \cite{BS} also conjecture that 
Theorem \ref{it1p6} also holds even if an upper bound on the number of vertices is known, however 
this conjecture is disproved in the following theorem.  

\begin{theorem}\label{it1p7}
\cite{BFRSV} Let $G$ be an anonymous directed graph with $n$ vertices.  Then a mobile agent that knows an upper 
bound on $n$ can traverse $G$ using only one pebble.  Furthermore, a mobile agent that does not know 
an upper bound on $n$ can traverse $G$ using $O(\log \log n)$ pebbles.  
\end{theorem}


In the results above, it is assumed the local orientation is assigned arbitrarily, i.e., no preproccessing 
was done to modify any of the port numbers.  This provides the motivation to fix a mobile 
agent, and then specifically arrange 
the port numbers for each vertex.  (Of course, in order to construct the local orientation, we can consider 
$G$ as a non-anonymous graph, and then discard these vertex identifiers before starting the traversal.)  A 
natural question arises, does there exist a local orientation of a graph, 
and mobile agent that does not have an upper bound of the vertices and uses no pebbles, that can traverse the graph?  

Theorem \ref{it2} shows there exists a local orientation and a corresponding finite automaton which 
makes traversal possible in linear time.  % Furthermore, 


\begin{theorem}\label{it2}
\cite{DJSS} For any graph $G$, there exists a local orientation and a corresponding finite automaton which 
will traverse $G$ in linear time.  Furthermore, the mobile agent will at most $10n$ edges during this traversal.  
\end{theorem}

The main idea of the proof of Theorem \ref{it2} given in \cite{DJSS} is to fix the local orientation of $G$ by considering cycles in $G$, that 
may or may not overlap.  By constructing subgraphs that have spanning cycles, the authors obtain several cycles, that together visit 
every vertex of $G$.  The remaining step is to merge the cycles into a single closed walk containing every vertex of $G$, and they show that 
this walk contains at most $10n$ edges.  The local orientation 
is arranged so that the mobile agent can simply follow increasing port numbers to stay on this walk.  
Hence a mobile agent can traverse $G$ as an anonymous graph in linear time with 
constant memory.  The authors of \cite{DJSS} ask whether there is a walk shorter than $10n$ edges that can be used 
to arrange the local orientation for a traversal.  Theorem \ref{it3} shows this improvement.  


An interesting variant of the graph traversal problem is periodic graph traversal, which 
requires that an algorithm visits every vertex 
infinitely many times in a periodic manner, where the period is the maximum number of edge traversals 
performed between two consecutive visits of a generic 
vertex, denoted by $\pi(n)$.  We can observe a trivial lower bound of $\pi(n)$ by considering a tree, where 
traversal is started at the root.  Clearly, each leaf vertex must be visited at least once, and since the graph is acyclic, each edge 
must be visited twice in order to return from a leaf vertex to the root.  Since any tree on $n$ vertices has $2n-2$ edges, we have $\pi(n)\ge 2n-2$.  
In the context of periodic traversal, another way to state Theorem \ref{it2} is to simply 
say that $\pi(n)\le 10n$ for all finite graphs.  Theorem \ref{it3} improves this upper bound.  

\begin{theorem}\label{it3}
\cite{I} If $G$ is a finite graph on $n$ vertices, there is a local orientation and a mobile agent that will periodically traverse $G$ with 
period $\pi(n)\le 4n-2$.
\end{theorem}

The authors of \cite{I} show this by is to start with an arbitrary spanning tree $T$ of $G$ with root $r$.  For each vertex $v\ne r$ the 
smallest ports will be assigned to edges in $T$, then all other ports will be on edges not in $T$.  Port $1$ will always be 
on the edge of the unique path 
from $v$ to $r$ in $T$.  A proof by induction is used to show $\pi(n)\le 4n-2$, by removing an edge of $T$ that has port $1$ at one of 
its endpoints.  
Furthermore, the author of \cite{I} conjectures that the best possible upper bound of $\pi(n)$ is $4n-c$, 
where $c$ is a constant.  The following theorem refutes this conjecture.   

\begin{theorem}\label{it4}
\cite{GKMNZ} If $G$ is a finite graph on $n$ there is a local orientation and a mobile agent that will periodically traverse $G$ with 
period $\pi(n)\le 3.75n-2$.
\end{theorem}

The idea of this proof of Theorem \ref{it4} given by the authors in \cite{GKMNZ} 
is to expand on the work of \cite{I} by further examining the spanning tree $T$.  The goal of this 
paper is to provide a local orientation that allows the mobile agent to recognize some specific 
subtrees, and move accordingly.  
They introduce the concept of an \emph{extended leaf}, which is an edge $uv$ of $T$ such that $v$ is a leaf, and $u$ is not incident to any 
leaves other than $v$.  Similarly a \emph{paired extended leaf} 
is an extended leaf connected to a vertex whose children contain at least two extended leaves.  Next they arrange the port numbers at each vertex, 
such that after the mobile agent visits a leaf or an extended leaf, it will always visit a paired extended leaf.  Furthermore, the mobile agent will 
traverse some edges outside of $T$.  We say that a penalty is paid at $v$ if the mobile agent leaves $v$ on an edge not in $T$.  The proof 
will color certain nodes based on the above leaf concepts, and based on a certain subtree of $T$ called the backbone.  By examining this backbone, 
and the 
vertex colors, the penalties paid (including both directions of a given edge) is shown to be at most $\frac{7}{4}n$, while 
at most $2n-2$ edges of the tree will be used.  Hence the bound $\pi(n)\le 3.75n-2$ is obtained.  The authors of \cite{GKMNZ} note that the idea 
of using subtrees has provided strong results as opposed to the cycle based proof of Theorem \ref{it2}, and conjecture whether spanning 
trees can be used more efficiently, or whether a new approach unrelated to spanning trees can be found.  


Furthermore, the authors in \cite{GKMNZ} noted that the best results 
known have thus far been found by using trees, and asked whether there was another 
approach to this problem that is not based on trees.  The second chapter of this thesis answers this question in the affirmative, by 
using an approach based on Hamiltonian cycles.  


Next, we examine results found for traversing non-anonymous graphs.  
Two well known solutions to this problem are the Depth-First Search (DFS) and Breadth-First 
Search (BFS) algorithms.  


\begin{center}\begin{tabular*}{\textwidth}{c}\hline\end{tabular*}\end{center}
\noindent \textbf{BFS}(Graph $G$, vertex $s$
%\begin{center}\begin{tabular*}{0.5\textwidth}{c}\hline\end{tabular*}\end{center}
\begin{algorithmic}[1] 
\STATE{  Set $ S = {s}$}
  \STATE{ Queue $Q$ = all neighbors of $s$}
  \WHILE{$Q$ is not empty}
 \STATE{    dequeue vertex $v$ from the front of $Q$ }
    \IF{$v$ is not in $S$}
      \STATE{ add $v$ to $S$}
      \STATE{ enqueue neighbors of $v$ onto the end of $Q$ }
    \ENDIF
  \ENDWHILE

\end{algorithmic}
\begin{center}\begin{tabular*}{\textwidth}{c}\hline\end{tabular*}\end{center}

We can picture 
the BFS algorithm as several mobile agents working in parallel, or taking turns moving one at a time.  
The BFS algorithm will move out from the starting vertex to every neighbour at once.  Then from each of those new vertices, every 
unvisited neighbour is visited.  So first all vertices at distance one from the start are visited, then all vertices at 
distance two, and so on.  

The DFS algorithm works differently; it first moves as far as possible away from the start untill there are no more adjacent vertices that 
have not been visited.  Then it will back up one vertex at a time, and attempt to find another route with unvisited vertices, and perform 
the same action.  

\begin{center}\begin{tabular*}{\textwidth}{c}\hline\end{tabular*}\end{center}
\noindent \textbf{DFS}(Graph $G$, vertex $s$)
\begin{algorithmic}[1] 
%DFS(Graph G, Vertex s)
 \STATE{  Set $S = {s}$}
  \STATE{ Stack $T =$ all neighbors of $s$}
  \WHILE{T is not empty}
    \STATE{ pop vertex $v$ from the end of $T$ }
    \IF{$v$ is not in $S$}
      \STATE{ add $v$ to $S$}
     \STATE{  push neighbors of $v$ onto the end of $T$  }
   \ENDIF
  \ENDWHILE
\end{algorithmic}
\begin{center}\begin{tabular*}{\textwidth}{c}\hline\end{tabular*}\end{center}

These algorithms traverse any $n$ vertex, $m$ edge graph in $O(m+n)$ time, and $\Omega(n\log n)$ memory.  These algorithms are not optimal.  
It was shown in \cite{AKLLR} that a random walk can traverse a graph using only $O(\log n)$ memory, and expected time $\Theta(mn)$.  Since $O(mn)$ is 
bounded $O(n^2)$, result seems to imply that there is a tradeoff; that we can use less memory by sacrificing the running time.    




This tradeoff was shown in the following theorem.  

\begin{theorem}
\cite{}  Any $n$ vertex graph can be traversed in memory $S$ 
and time $T$, such that $ST \le mn (\log n)^{K}$, where $K$ is a constant.  
\end{theorem}


This implies there is a spectrum of compramises between memory and running time for this problem.  One 
improvement to this would be a linear time algorithm that uses logarithmic memory for general graphs.  

...
....before geometric class, put in non-geometric results first.  most are phrased in terms of st traversal or universal 
traversal sequences.
...



One interesting class of non-anonymous graphs are geometric graphs.  A geometric 
graph is a graph embedded in Euclidean space, where each vertex is 
associated with the coordinates of a unique point in Euclidean space.  Planar graphs 
are an example.  
It turns out that planar graphs can be explored with only a single 
finite state automata with no extra memory.




\begin{theorem}
\cite{BM}..
\end{theorem}

proof idea


\begin{theorem}
\cite{BKOO}..
\end{theorem} 


proof idea






These results were extended to a larger class 
of graphs called quasi-planar graphs below.





\begin{theorem}
\cite{CDKOSU}..
\end{theorem}

The main idea in this solution is to first calculate a unique identifier for each edge based on the 
geometric information.  Then, by organizing the faces of the graph in the plane, a mobile agent is allowed to circle one face 
at a time, and switch to neighbouring faces at certain points.  This simulates a traversal of a spanning 
tree of the dual graph, which implies the result.  




\begin{theorem}
\cite{BF}..
\end{theorem}

proof idea





\subsection{Overview}

In the second chapter, we answer this question, if we are restricted to the class of $2$-connected, $P_3$-free graphs.  
Using a technique that is based on Hamiltonian cycles, we are able to obtain an upper bound of 
$\pi(n)\le 2n-2$.  This matches the lower bound given above, which is an optimal result.  



In the third chapter, we extend this result using a similar technique.  
First, we generalize the properties that are used by this strategy, i.e., properties of the 
unique edge identifire, and the faces of the graph.  We then show that any finite graph, if embedded in some surface, has 
these properties, and hence can be traversed with no extra memory, and the same running time of $O(m \log m)$.  



\newpage
\section{Periodic Traversal of $2$-connected, $P_3$-free Graphs}



For the remainder of this section, we assume $G$ is a $2$-connected, $P_3$-free graph.  
An arc $e$ of $\vec{G^2}$ is called a \emph{real} arc if $e$ is 
an arc of $\vec{G}$, otherwise $e$ is a \emph{virtual} arc.  
A directed path in $\vec{G^2}$ that contains only real arcs is a \emph{real path},  
and similarly a directed path containing only virtual arcs is a \emph{virtual path}. 
 

Suppose that $H$ is a Hamiltonian cycle of $G^2$ with the minimum number of virtual arcs.  Such a cycle exists 
since $G$ is $2$-connected, as demonstrated in the well known result of Fleishner in \cite{fl}.  
For our  
purposes, we will assume the vertices of $H$ are placed on a circle in the order they appear on $H$.  Moreover, we will assume  
a counterclockwise orientation of $H$, (which makes $H$ a directed cycle in $\vec{G^2}$).  We 
have a simple observation based on the minimality of $H$.  

  
\begin{obs}\label{obsx} If $(u,v)$ is any virtual arc of $H$, then there does not exist a (real or virtual) 
arc $(x,y)$ of $H$ such that $(x,u)$ and $(y,v)$ are real arcs of $\vec{G^2}$. 
\end{obs} 
\begin{proof} 
Suppose there does exist such an arc $(x,y)$ of $H$, such that 
$(x,u)$ and $(y,v)$ are real arcs.  Let $P$ be the directed $vx$-path in $H$,  
and let $Q$ be the directed 
$yu$-path in $H$.  We can now construct a Hamiltonian cycle $H'$ of $\vec{G^2}$ by following $P$, then the arc $(x,u)$,  
then $Q^{-1}$, and finally the arc $(y,v)$.  See Figure \ref{fig:forbid}.  
Since $(u,v)$ is a virtual arc, $H'$ has at least one fewer virtual arcs than $H$,  
a contradiction. 

\end{proof} 

\begin{figure} 
\centering 
\resizebox{6cm}{!}{\includegraphics{forbid.pdf}} 
\caption[A forbidden configuration based on minimality]
{The Hamiltonian cycle $H$ represented by a circle, and similarly $H'$ by a dashed line.\label{fig:forbid}} 
\end{figure} 
 

 
 \subsection{Relay Vertices and Wedges}



For each virtual arc $(u,v)$ of $H$, we assign  
a real directed $uv$-path of length two.   
This assigned path is called the \emph{relay path} of the arc $(u,v)$.   
The fact that a relay path exists for every virtual arc follows from the definition of $\vec{G^2}$.   
The unique internal vertex of the relay path  
is called the \emph{relay vertex} of the arc $(u,v)$.  Note that more than one such real directed path may exist for  
a virtual arc.  The relay paths can be chosen arbitrarily, it is only important that they are fixed.   
   
 
 

A vertex may be the relay vertex for more than one 
virtual arc.  Hence we will group together %consecutive 
virtual arcs that are consecutive on $H$ if they have the same relay vertex.  
If $P$ is a maximal virtual (directed) 
path in $H$, containing at least one virtual arc, such that all virtual arcs of $P$ share a common relay vertex $w$,  
then the subgraph $W$ of $\vec{G^2}$ consisting of $P$, the vertex $w$, and the relay path of every arc of $P$, is  
called a \emph{wedge}; see Figure \ref{fig:wedge} for an example.  
We call $P$ the \emph{virtual path of the wedge} $W$.  
Similarly, arcs of $P$ are called \emph{virtual arcs of the wedge} $W$, and the vertex $w$ is called 
the \emph{relay vertex of the wedge} $W$.  Real arcs of  
$W$ are called  \emph{ribs} of $W$.  If we suppose the terminal vertices of $P$ are $u$ and $v$ such that 
$P$ is a $uv$-path, we refer to $u$ as the 
\emph{left external vertex} of $W$, and 
$v$ as the \emph{right external vertex} of $W$; both are called \emph{external vertices} of $W$.  Internal vertices  
of $P$ are called \emph{internal vertices} of the wedge.  The rib $(u,w)$  
is the \emph{left external rib} of $W$, and the rib  
$(w,v)$ is the \emph{right external rib} of the $W$; they are both referred to as \emph{external ribs} of $W$.  Real  
arcs of $W$ that are incident to an internal vertex are called \emph{internal ribs} of $W$.  %If $x$ is 
We define the \emph{size} of a wedge $W$, denoted $s(W)$, as the number of 
vertices of its virtual path; 
see Figure \ref{fig:wedge} for an example of a wedge of size five.    
 
\begin{figure}[htp] 
\centering 
\resizebox{9cm}{!}{\includegraphics{wedge.pdf}}\\ 
\caption[A wedge of size five]{A wedge of size five.  The ribs are real arcs of $\vec{G^2}$ and are represented in this figure  
by thicker lines.  The virtual path consists of virtual arcs of $\vec{G^2}$ and are represented by regular lines.\label{fig:wedge}} 
\end{figure} 
 

Note that ribs of a wedge are always real arcs of $\vec{G^2}$.  
%However, an external 
%rib of a wedge may be incident to consecutive vertices of $H$.  
%Indeed, if $(w,v)$ is the right external rib of a wedge $W$ such that its inverse $(v,w)$ is an arc of $H$, 
%then the wedge $W$ is a \emph{right tied} wedge; similarly  
%if $(u,w)$ is the left external rib of $W$ such that $(w,u)$ is an arc of $H$, then the wedge is a \emph{left tied} wedge.  
%A wedge that is neither left tied nor right tied is called a \emph{free wedge}.   
The following lemma characterizes how two wedges can interact. 
 
\begin{lemma}\label{lemwedge} Suppose $W_1$ and $W_2$ are distinct wedges.  Then \newline 
$(i)$  The wedges $W_1$ and $W_2$ have no virtual arcs in common.  \newline 
$(ii)$  The wedges $W_1$ and $W_2$ have no ribs in common.\newline   
$(iii)$  If $e$ is a rib of $W_1$, $e^{-1}$ is not a rib of $W_2$.
\end{lemma} 
\begin{proof} 

Let $W_1$ and $W_2$ be wedges with relay vertices $w_1$, $w_2$ 
and virtual paths $P_1$, $P_2$, respectively.   

To show $(a)$, suppose to the contrary that $e$ is a virtual arc of both $W_1$ and $W_2$.   
Now $w_1$ is the relay vertex of $e$, since $e$ is a virtual arc of $W_1$.  But 
$e$ is also a virtual arc of $W_2$, so $w_2$ is the relay vertex of $e$.  Hence $w_1 = w_2$, since 
each virtual arc has exactly one relay vertex.  Since we 
supposed that $W_1 \ne W_2$, it follows that $P_1 \ne P_2$.  Since $e$ is an arc of both $P_1$ and $P_2$, it must be the case that  
either one of the paths is a subpath of the other, contradicting the maximality of the smaller path; or $P_1$ and $P_2$ overlap, in  
which case neither path is maximal, again a contradiction. 
Therefore $W_1$ and $W_2$ have no virtual arcs in common. 
 

%\begin{figure}[htp] 
%\centering 
%\resizebox{6cm}{!}{\includegraphics{fbw.pdf}} 
%\caption{insert generic caption \label{fig:fbw}} 
%\end{figure} 
 
We prove $(ii)$ in two cases, first suppose $w_1= w_2$.  Suppose 
to the contrary that $e=(w_1,v)$ is a rib of both  
$W_1$ and $W_2$.  If $e$ is an internal 
rib of either $W_1$ or $W_2$, then $v$ is incident to a virtual arc that is in both $P_1$ and $P_2$, which contradicts 
$(i)$.  
So $e$ is an external rib of both $W_1$ and $W_2$.   
Suppose that 
$e$ is the right external rib of $W_1$, (the case 
where $e$ is a left external vertex of $W_1$ is symmetric).  So $v$, is the right external vertex  
of $W_1$.  If $e$ is also the right external rib of $W_2$, then as above, $v$ is incident to a virtual arc that is in both 
$P_1$ and $P_2$, which contradicts $(i)$.  Therefore $e$ is the left external rib of $W_2$.  This is a contradiction, since the head 
of $e$ is $v$, and $v\ne w_2$.  


%Since $e$ is not an internal rib of $W_2$, $v$ is an external vertex of $W_2$.  If $v$ is also the right external vertex of 
%$W_2$, then $v$ is incident to a virtual arc that is in both wedges, which contradicts $(i)$.  
%So $v$ is the left external vertex of $W_2$, see Figure \ref{fig:wedgedub}.  
%This implies $e=(v,w_2)$.  Hence $e=(w_1,v)=(v,w_2)=(v,w_1)$, a contradiction since $v\ne w_1$.  


%Now suppose $w_1 \ne w_2$.  Suppose to the contrary the real arc $e$ of $\vec{G^2}$ is a 
%rib of both wedges.  This implies $e$ is incident to both relay vertices.  Without loss of generality, 
%let $e=(w_1,w_2)$, (the case when $e=(w_2,w_1)$ is similar).

%But $e$ cannot be the left  
%external rib of $W_2$, then the union of $P_1$ and $P_2$ is a longer path than both $P_1$ and $P_2$ alone, and all arcs  
%in the union are virtual and share the same relay vertex.  This contradicts the choice of $P_1$ and $P_2$, hence the  
%wedges have no ribs in common, so $(b)$ is proven. 

%suppose that $e$ is an arc common to both wedges.  From $(a)$, $e$ is not a virtual arc, so it must be a rib of  
%both wedges.  Also, from $(b)$ we know that $w_1 \ne w_2$.  Since $e$ is a rib of both $W_1$ and  
%$W_2$, this forces $e=w_1w_2$.  So  
%$w_1$ is also an internal vertex of $W_2$, and $w_2$ is also an internal vertex of $W_1$; see Figure \ref{fig:wedgeflip}. 
%\includegraphics{wedgeflip.pdf} 

Now suppose $w_1 \ne w_2$.  Suppose to the contrary the real arc $e$ of $\vec{G^2}$ is a 
rib of both $W_1$ and $W_2$.  This implies $e$ is incident to both $w_1$ and $w_2$.  Without loss of generality, 
let $e=(w_1,w_2)$.  
First we will show that $w_1$ is an external vertex of $W_2$, and similarly $w_2$ is an external vertex of $W_1$.   
Suppose to the contrary 
that $w_1$ is an internal vertex of $W_2$, (we obtain a similar contradiction if 
$w_2$ is an internal vertex of $W_1$).  
Therefore there are two virtual arcs of $W_2$ incident with $w_1$, say $(u,w_1)$ and $(w_1,v)$.  
There is at least one virtual arc of $W_1$ incident with $w_2$, call it $h$.  
Suppose that $h=(x,w_2)$.  We know that $(x,w_1)$ is a real arc since  
it is a rib of $W_1$, similarly $(w_2,v)$ is a real arc since it is a rib of $W_2$, see Figure \ref{fig:fbw}.  
This contradicts Observation \ref{obsx}.  If $h=(w_2,x)$ we get a similar  
contradiction.  Therefore $w_1$ is an external vertex of $W_2$, and similarly $w_2$ is an external vertex of $W_1$.  
 
It follows that $e=(w_1,w_2)$ is an external rib of both $W_1$ and $W_2$.  Since $w_1$ is the 
tail of $e$, $e$ is the right 
external rib of $W_1$, and similarly $e$ is also the left external rib of $W_2$.  %; see Figure \ref{fig:wedgecross}$(ii)$.  
Therefore $(w_1,v)$ is a virtual arc of the wedge $W_2$, and 
$(x,w_2)$ is a virtual arc of the wedge $W_1$, see Figure \ref{fig:fbw}.  So $(x,w_1)$ and $(w_2,v)$ are ribs 
of their respective wedges.  Since all ribs are real arcs, this contradicts Observation \ref{obsx}.  
This concludes the proof of $(ii)$.   



To show $(iii)$, let $e=(u,v)$ be a rib of $W_1$.  Suppose to the contrary that $e^{-1}=(v,u)$ is a rib of $W_2$.  If 
$e$ is an internal rib of $W_1$, then $e^{-1}$ is also an internal rib of $W_1$, which contradicts part $(ii)$.  
So $e$ is an external rib of $W_1$; similarly $e^{-1}$ is an external rib of $W_2$.  
Suppose without loss of generality that 
$e$ is the right external rib of $W_1$, (the case $e$ is the left external rib of $W_1$ is symmetric).  So $u=w_1$, and $v$ is the 
right external vertex of $W_1$.  

\begin{figure}[htp] 
\centering 
\resizebox{6cm}{!}{\includegraphics{fbw.pdf}} 
\caption[An edge in two relay paths]{The relay paths of the virtual arcs $(x,w_2)$ and $(w_1,v)$ both contain $e$.   \label{fig:fbw}} 
\end{figure} 
%\begin{figure}[htp] 
%\begin{minipage}[b]{0.5\linewidth}
%\centering 
%\includegraphics[width=6cm]{wedgeflip.pdf} 
%\newline
%$(i)$
%\end{minipage}
%\hspace{0.5cm}
%\begin{minipage}[b]{0.5\linewidth}
%\centering 
%\includegraphics[width=6cm]{wedgecross.pdf}
%\newline
%$(ii)$
%\end{minipage}
%\caption{ The arcs $(y,w_1)$ and $(x,w_2)$ are virtual arcs of 
%$H$, and the edges $e$, $xw_1$ and $yw_2$, are real edges of $\vec{G}$. \label{fig:wedgecross}} 
%\end{figure} 


If $e^{-1}$ is 
the left external rib of $W_2$, then $u=w_2$ and $v$ is the left external vertex of $W_1$.%  , see Figure \ref{fig:wedgedub}.  
So the union of $P_1$ and $P_2$ is a 
virtual path such that each (virtual) arc of this new 
path has relay vertex $u$, m
which contradicts the maximality of $P_1$ (and $P_2$).  

Next suppose $e^{-1}=(v,u)$ is the right external rib of $W_2$, and hence 
$v=w_2$.  Hence $e=(w_1,w_2)$, and $e^{-1}=(w_2,w_1)$.  Since $w_2$ is the right external vertex of the wedge $W_1$, there is a 
vertex $x$ such that $(x,w_2)$ is a virtual arc of $W_1$, and $(x,w_1)$ is a rib of $W_1$.  Similarly, there is a vertex $y$ 
such that $(y,w_1)$ is a virtual arc of $W_2$, and $(y,w_2)$ is a rib of $W_2$.  

Let $P$ be the path in $G$ containing 
the edges $xw_1$, $w_1w_2$, $w_2y$.  Since all these vertices are distinct, $P$ is a path of length three in $G$.  To show that $P$ is 
an induced subgraph of $G$, first notice that $xw_2$ and $yw_1$ are clearly virtual edges.  If $xy$ is a real edge, then $(x,y)$ and $(y,x)$ are 
real arcs, which contradicts Observation \ref{obsx}.  So $xy$ is not a real edge, which implies $P$ is an induced subgraph of $G$, a contradiction 
since $G$ is $P_3$-free.  Therefore $e^{-1}$ is not a rib of $W_2$.  %This concludes the proof.   
\end{proof}


We can see that an external 
rib of a wedge cannot be an arc of $H$.  However, an external rib may be incident to consecutive vertices of $H$.  
Indeed, if $(w,v)$ is the right external rib of a wedge $W$ such that its inverse $(v,w)$ is an arc of $H$, 
then we say that the wedge $W$ is a \emph{right tied} wedge; similarly  
if $(u,w)$ is the left external rib of $W$ such that $(w,u)$ is an arc of $H$, then $W$ is a \emph{left tied} wedge.  
A wedge that is neither left tied nor right tied is called a \emph{free wedge}.   
Next, we show that there are does not exist a  
wedge that is both left tied and right tied.  

\begin{lemma}\label{lemboth}
There does not exist a wedge of $\vec{G^2}$ that is both left tied and right tied.
\end{lemma}
\begin{proof}
Suppose to the contrary that the wedge $W$ is both left tied and right tied.  It is 
clear that $W$ contains all the vertices of $G$.  
Let $w$ be the relay vertex of $W$, $u$ be the left external vertex of $W$, and $v$ be the right external vertex of $W$.  
If $W$ contains only 
these three vertices, then $(u,v)$ is a virtual arc of $W$.  Hence there is no arc joining $u$ and $v$ 
in $\vec{G}$.  However, this implies that $w$ is a cut vertex in $G$, a 
contradiction since $G$ is $2$-connected.  Now suppose $G$ has at least four vertices.

\begin{figure}[htp] 
\centering 
\resizebox{6cm}{!}{\includegraphics{bothtied.pdf}} 
\caption[Why a wedge cannot be both left and right tied]{The vertex $w$ is the relay vertex of a wedge that is both left tied and right tied.
\label{fig:bt}} 
\end{figure} 

Let $P$ be the virtual path of $W$, so $P$ is a directed $uv$-path.  Let $x\ne v$ be the vertex adjacent to 
$u$ on $P$.  Such a vertex exists since $\vec{G}$ has at least four vertices.  
Since $G$ is $2$-connected, $d(x) \ge 2$, so there is at least one real arc other than the rib $(w,x)$ incident to $x$, 
say $e=(x,y)$.  Since $(u,x)$ is a virtual arc, $u\ne y$, 
(but it is possible that $y=v$).  Since $(x,y)$ is a real arc, there exists at least 
one internal vertex of $W$ that lies between $x$ and $y$ on the path $P$; see Figure \ref{fig:bt}.  Let $s$ be the vertex 
following $x$ on $P$, and 
$t$ be the vertex preceding $y$ on $P$, (it is possible that $s=t$).  Let $P_1$ be the $st$-subpath of $P$, and $P_2$ be 
the $yv$-subpath of $P$, (either of which may not contain any arcs).  Since there is a real path of length two connecting $s$ and $u$, 
$(s,u)$ is either a real arc or a virtual arc of $\vec{G^2}$.  Similarly $(v,t)$ is an 
arc of $\vec{G^2}$, (that is either real or virtual).  Let $H'$ be the cycle in $\vec{G^2}$ following 
$(u,w)$, $(w,x)$, $(x,y)$, $P_2$, $(v,t)$, $P_1^{-1}$, and $(s,u)$, see Figure \ref{fig:bt}.  
Clearly, $H'$ is a Hamiltonian cycle of $\vec{G^2}$.  
This is a contradiction since $H$ contains only two real arcs, (namely $(v,w)$ and $(w,u)$), while 
$H'$ contains at least three real arcs, (namely $(u,w)$, $(w,x)$, and $(x,y)$).  Therefore $W$ cannot be both left tied and right tied.
\end{proof}


For any vertex $v$, there may be several distinct wedges with relay vertex $v$; in the following we identify these wedges.  
If $v$ is the relay vertex of $k\ge 1$ wedges, we order these wedges at $v$ based on their occurrence along $H$.  
The \emph{list of ordered wedges} $W_1,W_2,\ldots,W_k$ \emph{at} $v$  
is the ordered list of all wedges with the common relay vertex $v$ such that for $W_i$ and $W_j$ with $i<j$, the virtual path of $W_i$  
occurs before the virtual path of $W_j$ when following $H$ starting from $v$; for example see Figure \ref{fig:wedgeorder}.  
When the list of ordered 
wedges at a vertex is understood, we will write $s_i$ for $s(W_i)$, (recall that $s(W)$ denotes the size of the wedge $W$).   
If $e$ is a  
real arc incident with $v$, we say that $e$ is an \emph{isolated arc} of $v$ if neither $e$ nor $e^{-1}$ are ribs of any wedge 
in the list of ordered wedges at $v$.


 
\begin{figure}[htp] 
\centering 
\resizebox{5cm}{!}{\includegraphics{wedgeorder.pdf}} 
\caption[The ordered list of wedges at a vertex]{The list of ordered wedges at $v$ is $W_1,W_2,\ldots,W_k$.  In this example, $W_1$ is a left tied wedge.  
\label{fig:wedgeorder}} 
\end{figure} 


In the following sections, we will show how to turn the Hamiltonian cycle $H$ in $\vec{G^2}$ into a Hamiltonian walk $H^*$ in $\vec{G}$.  We will 
use our wedges as the main ingredient in this process, along with two specific arcs at each vertex.  These arcs will be called the 
incoming and outgoing arcs of the vertex.  

\begin{definition}\label{def:io}
%If $e$ is a backtrack arc of $v$, then $e$ is an isolated arc of $v$.
Given vertex $v$, let $(x,v)$ and $(v,y)$ be the two arcs of $H$ incident with $v$.  
\begin{itemize}
\item The incoming arc of $v$ is either   
$(x,v)$ if it is real, or the real arc $(w,v)$, where $w$ is the relay vertex of $(x,v)$.
\item Similarly, the  
outgoing arc of $v$ is either $(v,y)$ if it is real, or  
the real arc $(v,w)$, where $w$ is the relay vertex of $(v,y)$.  
\end{itemize}
If $e$ is the incoming arc of $v$ and 
$e^{-1}$ is the outgoing arc of $v$, we say that $e$ is a backtrack arc of $v$, (in which case 
$e^{-1}$ is also a backtrack arc of $v$).   
\end{definition}


Note that the incoming and outgoing  
arcs of a vertex are always real arcs.  By definition,  
each vertex has exactly one incoming arc, and one outgoing arc.  
Since the relay vertices of all virtual arcs are fixed, the incoming and 
outgoing arcs 
are also fixed for every vertex of $\vec{G}$.  In general, incoming and outgoing arcs of a vertex 
may or may not be isolated arcs of that vertex.  % (in Lemma \ref{lemmaext}, we further investigate the 
%cases where these arcs are not isolated).  
In the following we let $a$ and $b$ 
be the incoming and outgoing arcs of the vertex $v$, respectively

We first consider cases when $a\ne b^{-1}$, i.e., $v$ does not have a backtrack arc; there are four possible 
configurations.  If both $a$ and $b$ are 
real arcs of $H$, then they form a real path of length two along $H$ containing $v$ as an internal vertex, see Figure \ref{fig:iowedge}$(i)$.  
If $v$ is incident 
to two virtual arcs of $H$, then both $a$ and $b$ are arcs of disjoint relay paths, as shown in Figure \ref{fig:iowedge}$(ii)$.  Similarly, 
if exactly one of $a$ or $b$ is an arc of $H$, then $v$ is incident to at least one relay path, as shown in Figures 
\ref{fig:iowedge}$(iii)$ and \ref{fig:iowedge}$(iv)$.  
In the following lemma, we investicate how these arcs interact with wedges when they are not isolated arcs of $v$.  

\begin{figure}[htp] 
\centering 
\resizebox{9cm}{!}{\includegraphics{iowedge.pdf}} 
\caption[The incoming and outgoing arcs of a vertex]
{The four of the possible configurations where $a$ is the incoming arc of $v$, $b$ is the outgoing arc of $v$, and $a\ne b^{-1}$.
\label{fig:iowedge}}
\end{figure} 
 


\begin{lemma}\label{lemmaext} 
Let $a$ be the 
incoming arc of $v$, and $b$ be the outgoing arc of $v$, such that $a\ne b^{-1}$.  Then:
 
\noindent $(i)$ If $a$ is not an isolated arc of $v$, then $a^{-1}$ is the right external 
rib of a right tied wedge $W$ with relay vertex $v$. % Furthermore, if $G$ is $P_3$-free, $W$ is a right tied wedge.  

\noindent $(ii)$ If $b$ is not an isolated arc of $v$, then $b^{-1}$ is the left external 
rib of a left tied wedge $W$ relay vertex $v$.   %Furthermore, if $G$ is $P_3$-free, $W$ is a left tied wedge.    
\end{lemma} 
\begin{proof} 

We prove only $(i)$; the proof for $(ii)$ is symmetric.  
Suppose $a$ is not an isolated arc of $v$.  It follows that either $a$ or $a^{-1}$ is a rib of some wedge with relay vertex $v$.  
First we show that $a=(u,v)$ cannot be a rib of any wedge with relay vertex $v$.  
Then we will show that $a^{-1}$ must be a rib of a right tied wedge with relay vertex $v$.  % Finally, we will show that this wedge must be right tied.

To this end, suppose to the contrary that $a$ is 
a rib of the wedge $W$ with relay vertex $v$.  It follows that $a$ is not an arc of $H$, because 
wedges cannot contain any real arcs of $H$.  Hence, by Definition \ref{def:io}, $u$ 
is the relay vertex of the virtual arc $(x,v)$, and hence the relay vertex of some wedge $W'$ containing $(x,v)$.   
But now $a$ is a rib of both $W$ and $W'$.  Clearly $W\ne W'$, since 
they have different relay vertices.  This contradicts Lemma \ref{lemwedge}$(ii)$.  Therefore $a$ is not a rib of any wedge with 
relay vertex $v$.


Since $a$ is not an isolated arc of $v$, we conclude that there exists a wedge $W$ with relay vertex $v$ such that $a^{-1}$ is a rib of $W$.  
Since $a$ is the incoming arc of $v$, we have two cases by Definition \ref{def:io}.  
First, suppose that $a$ is an arc of $H$.  
Since $a=(u,v)$ is a real arc of $H$, it follows that $u$ is the right external vertex of $W$.  
Thus $a^{-1}=(v,u)$ is 
the right external rib of $W$.  Furthermore, since $(u,v)$ is an arc of $H$, $W$ is right tied.

For the second case, suppose $a$ is not an arc of $H$.  Hence $(x,v)$ is a virtual arc 
of $H$ such that $u$ is the relay vertex of $(x,v)$, (by Definition \ref{def:io}).  This implies there is a wedge $W'$ with 
relay vertex $u$ such that $(x,v)$ is a virtual arc of $W'$.  Hence $a$ is a rib of $W'$.  However, this 
contradicts Lemma \ref{lemwedge}$(iii)$, since $a^{-1}$ is a rib of $W$, and $W\ne W'$.   

\end{proof} 
 


In the following, we consider the case when $a=b^{-1}$.  The next lemma shows that in this situation, $a$ and $b$ 
must be isolated arcs of $v$.


\begin{lemma}\label{lemmaback} 
If $a$ is the incoming arc of $v$, and $b$ is the outgoing arc of $v$, and $a=b^{-1}$, then $a$ and $b$ are 
isolated arcs of $v$.
%If $e$ is a backtrack arc of $v$, then $e$ is an isolated arc of $v$.  
%For any vertex $v$, and real arc $e=(u,v)$, $e$ is a backtrack arc of $v$ if and only if  
%either $e$ is the internal rib of some wedge with relay vertex $w\ne v$;  
%or $e$ is both an arc of $H$ and an external rib of some tied wedge with relay vertex $w \ne v$, see Figure \ref{fig:wedgebkt}. 
\end{lemma} 
\begin{proof} 

By Definition \ref{def:io}, there are two cases for each of $a$ and $b$.  First suppose both $a$ and $b$ are 
arcs of $H$.  Since $a=b^{-1}$, and since $H$ is a directed cycle, $H$ contains only these two arcs, and hence $H$ has two vertices.  
This is a contradiction since $\vec{G}$ has at least three vertices.  From now on, suppose at most of either $a$ or $b$ is an 
arc of $H$.  We show that $a$ is an isolated arc of $v$ by showing that neither $a$ nor $a^{-1}$ is a rib of any wedge with relay 
vertex $v$.  Since $a=b^{-1}$, this implies that $b$ is also an isolated arc of $v$.  



Next suppose $a$ is an arc of $H$, and $b$ is not.  So $a$ is not a rib of any wedge.  By Definition \ref{def:io}, 
$b=(v,w)$ such that $w$ is the relay vertex of the virtual arc $(v,x)$ of $H$, see Figure \ref{fig:wedgebkt}$(i)$.  Now 
$w$ is the relay vertex for a left tied wedge $W$, and $b$ is the left external rib of $W$.  
By Lemma \ref{lemwedge}$(ii)$, $b$ is not a rib of any wedge with relay vertex $v$.  Therefore $a$ and $b$ are isolated arcs of $v$.  
If $b$ is an arc of $H$ and $a$ is not, the argument is similar.  

%Now 
%suppose to the contrary that $a$ is not an isolated arc of $v$, so $a$ is a rib of the wedge $W'$ with relay vertex $v$.  Since $a=(w,v)$ is 
%an arc of $H$, $a$ is the right external rib of $W'$, and $W'$ is a right tied wedge.  This contradicts Lemma \ref{lemwedge}$(iii)$, 
%since $b$ is the left external rib of $W$, and $a$ is the right external rib of $W'$, and $a=b^{-1}$.  Thus 
%$a$ and $b$ are isolated arcs of $v$.  
%If $b$ is an arc of $H$ and $a$ is not, we again obtain the desired result with a symmetric argument.  


Finally, suppose neither $a$ nor $b$ are arcs of $H$.  By Definition \ref{def:io}, $a=(w,v)$ such that $w$ is the relay vertex of the 
virtual arc $(x,v)$, and similarly $b=(v,w)$ such that $w$ is the relay vertex of the virtual arc $(v,y)$.  Hence $a$ and $b$ are 
internal ribs of the wedge $W$ with relay vertex $w$, see Figure \ref{fig:wedgebkt}$(ii)$.  
By Lemma \ref{lemwedge}$(ii)$, this implies neither $a$ nor $b$ are ribs of any wedge other than $W$.  Therefore, 
they are isolated arcs of $v$.  


\end{proof} 




\begin{figure}[htp] 
\begin{minipage}[b]{0.5\linewidth}
\centering 
{\includegraphics[width=6cm]{wedgebka.pdf}} 
\newline
$(i)$
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.5\linewidth}
\centering
{\includegraphics[width=6cm]{wedgebkb.pdf}} 
\newline
$(ii)$
\end{minipage}
\caption[Examples of a backtrack arc of a vertex]{Two possible configurations showing how $v$ can have a backtrack arc, 
where $a$ is the incoming arc of 
$v$ and $b$ is the outgoing arc of $v$, and $a=b^{-1}$.  \newline  
$(i)$  The vertex $v$ an external vertex of a tied wedge with relay vertex $w\ne v$.  \newline  
$(ii)$ The vertex $v$ is an internal vertex of a wedge with relay vertex $w\ne v$.  \label{fig:wedgebkt}} 
\end{figure} 



We now have a good understanding of how wedges interact with these incoming and outgoing arcs.  
The next subsection describes how to assign port numbers to the arcs of $\vec{G}$.

\subsection{Assigning Port Numbers}
\label{sec:pn}


In the previous section, we have identified the incoming and outgoing edge for every vertex.  
These have been chosen so that they constitute 
a Hamiltonian walk in the original graph $G$.  In this section, we will assign numbers 
to each arc of $\vec{G}$, called port numbers.  
%These port numbers will be positive integers not greater than the degree of the vertex 
%plus three.  
Once assigned, these port numbers will be 
used by the robot in Section \ref{sec:robot} for the periodic traversal of $\vec{G}$.  


Let $e$ be an arc of $\vec{G}$.  One port number will be assigned to $e$, and one will be assigned 
to $e^{-1}$.   When every arc has a port, we call this a \emph{port numbering} of $\vec{G}$.  
If each arc has exactly one port number that is chosen uniquely from the set 
$\{ 1 , 2 , 3 , \ldots , d(v)\}$, where $v$ is the tail vertex of the arc, we call this a \emph{valid} port numbering of $\vec{G}$.  
%When every arc has a port, we call this a \emph{port numbering} of $\vec{G}$.  
When comparing two port numbers, we use 
the natural ordering of integers.  By associating these port numbers with the tail of the arc, this will simulate 
a port numbering the underlying graph $G$, where each edge has two ports, one at each vertex.   
 
  
We will now describe how to assign an interval of port numbers to arcs of a wedge.   
Given any wedge $W$ with relay vertex $v$,  
and virtual path $P=u_1,u_2,u_3,\ldots,u_{s(W)}$, we  
say that an interval $[p,q]$ \emph{is assigned to the wedge} $W$ if $1\le p<q \le d(v)$, $s(W)=q-p+1$, and 
port $p+i-1$ is assigned to $(v,u_i)$ for all $1\le i\le s(W)$.   
We say that the interval $[p,q]$ \emph{is assigned to} a set of wedges $\{W_1,W_2,\ldots,W_k\}=\{W_i\}_{i=1}^k$, 
if all wedges have a common relay vertex, 
$\sum_{i=1}^k s(W_i) = q-p+1$, 
$[p,p+s(W_1)-1]$ is assigned to $W_1$, and 
$[p+\sum_{i=1}^{j-1} s(W_i), p+\sum_{i=1}^j s(W_i) -1]$ is assigned to $W_j$ for $1< j\le k$.  

 
The assignment of the port numbers will be accomplished by applying the Port-Numbering procedure detailed below to 
each vertex $v$ of $\vec{G}$.  After identifying the incoming and outgoing arcs of $v$, there are five ways 
that these arcs can interact with wedges.  This leads to the five exclusive conditions for the 
what we will refer to as the five subroutines of the Port-Numbering procedure, starting at lines 
\ref{line:sr1}, \ref{line:sr2}, \ref{line:sr3}, \ref{line:sr4}, and \ref{line:sr5}, respectively.  Each subroutine 
will first assign port numbers to the incoming and outgoing arcs of $v$ if they are isolated, and then assigns 
an interval of ports to every wedge with relay vertex $v$.  The only wedges that are considered seperately are 
tied wedges, (see Lemma \ref{lemmaext}).  The ports and intervals are chosen so that 
the incoming and outgoing arcs always have consecutive port numbers.  
Finally, the Port-Numbering procedure will run the arbitrary-ports subprocedure, which 
arbitrarily assigns 
a port to each arc with tail vertex $v$ 
that does not already have a port.  This procedure also ensures that the port $d(v)$ is not assigned to any arc with tail 
vertex $v$ in the arbitrary-ports subroutine.  




\begin{center}\begin{tabular*}{\textwidth}{c}\hline\end{tabular*}\end{center}
\noindent \textbf{procedure Port-Numbering}$(v)$
\begin{algorithmic}[1] 
\STATE{Let $a$ be the incoming arc of $v$} %\label{line:t1}
\STATE{Let $b$ be the outgoing arc of $v$}%\label{line:t2}
\STATE{Set $k$ such that $v$ is a relay vertex of $k$ distinct wedges} %\label{line:t3}
\IF{ $k > 0$} %\label{line:t4}
   \STATE{Let $\{W_i\}_{i=1}^k$ be the list of ordered wedges at $v$}% \label{line:t5}
\ENDIF %\label{line:t6}



\IF{$a=b^{-1}$} \label{line:sr1}
\STATE{Assign $d(v)$} to $b$ \label{line:backtrack}
\IF{$k>0$}
  \STATE{Assign $[d(v)-\sum_is_i,d(v)-1]$ to $\{W_i\}_{i=1}^k$}\label{line:fill1} %
  \ENDIF
\ENDIF



\IF{$a\ne b^{-1}$ and both $a$ and $b$ are isolated arcs of $v$}\label{line:sr2}
\STATE{Assign $d(v)-1$ to $a^{-1}$}\label{line:iso1}
\STATE{Assign $d(v)$ to $b$} \label{line:iso2}
\IF{$k>0$}
    \STATE{Assign $[d(v)-\sum_is_i-1,d(v)-2]$ to $\{W_i\}_{i=1}^k$}\label{line:fill2}
\ENDIF
\ENDIF




\IF{$a\ne b^{-1}$ and both $a$ and $b$ are not isolated arcs of $v$}\label{line:sr3}
    %\STATE{Assign  $[d(v)-s_{1}-s_{k}+1,d(v)-s_1]$ to $W_{1}$\label{line:bothin}}
    \STATE{Assign   $[d(v)-s_{1} +1 ,d(v)]$ to $W_{1}$\label{line:bothout}}
   \STATE{Assign  $[d(v)-s_{1}-s_{k}+1,d(v)-s_1]$ to $W_{k}$\label{line:bothin}}
    \IF{$k \ge 3$}
      \STATE{Assign $[ d(v)-\sum_is_i+1,d(v)-s_1-s_{k}]$ to $\{W_i\}_{1<i<k}$     \label{line:fill3}}
    \ENDIF
\ENDIF %end subroutine



\IF{$a\ne b^{-1}$, $a  $ is an isolated arc of $v$ but $b$ is not}\label{line:sr4}
  \STATE{Assign $d(v)-s_1$ to $a^{-1}$\label{line:onlya}}
  \STATE{Assign $[d(v)-s_1+1,d(v)]$ to $W_1$\label{line:outtied}} 
   \IF{$k \ge 2$}
       \STATE{Assign $[d(v)-\sum_{i}s_i,d(v)-s_1-1]$ to $\{W_i\}_{i>1}$\label{line:fill4}}
   \ENDIF
\ENDIF%end subroutine




\IF{$a\ne b^{-1}$, $b$ is an isolated arc of $v$ but $a$ is not\label{line:sr5}}
  \STATE{Assign $[d(v)-s_k,d(v)-1]$ to $W_k$\label{line:intied}}
  \STATE{Assign $d(v)$ to $b$\label{line:onlyb}}
\IF{$k \ge 2$}
  \STATE{Assign  $[d(v)-\sum_{i}s_i,d(v)-s_k-1]$} to $\{W_i\}_{i<k}$\label{line:fill5}
\ENDIF 



 
\ENDIF % matches final case
\STATE arbitrary-ports$(v)$
\end{algorithmic} 
\begin{center}\begin{tabular*}{\textwidth}{c}\hline\end{tabular*}\end{center}


In the following lemma, we show that the Port-Numbering procedure will generate a valid port numbering of $\vec{G}$.  


\begin{lemma}
The procedure Port-Numbering will produce a valid port numbering of $\vec{G}$.
\end{lemma}
\begin{proof}
It is sufficient to show the following:
\newline
$(i)$ If a vertex $v$ sees port $p$, then  $1\le p\le d(v)$. \newline
$(ii)$ If two distinct arcs share the same tail vertex, they are assigned different ports.\newline
$(iii)$ Every arc of $\vec{G}$ has been assigned exactly one port. 


To show $(i)$, suppose that the arc $e=(v,u)$ has port $p$.  Let $a$ be the incoming arc of 
$v$, and $b$ be the outgoing arc of $v$.  

If $p$ was not assigned in an interval, then 
by inspection of the procedure, 
$p$ is either $d(v)-1$, $d(v)$, or $d(v)-s_1$.  Consider $p=d(v)-s_1$; the other cases are trivial.  So 
$p$ was assigned on line \ref{line:onlya}, which is part of the subroutine on line \ref{line:sr4}.  So 
$s_1$ is the size of the wedge $W_1$.  Since $b$ is an isolated arc of $v$, $2\le s_1\le d(v)-1$.  Therefore 
$1\le p \le d(v)$.

Now suppose $p$ belongs to 
some interval $I=[q,r]$, where $I$ was assigned to some wedge (or set of wedges) with relay vertex $v$.  
Let $W_1,W_2,\ldots,W_k$ be the list of ordered wedges at $v$.  Since $q\le p\le r$, it is sufficient to 
show that $q\ge 1$, and $r\le d(v)$.  

First, we show that $q\ge 1$.  
By inspection of the procedure, $q$ is of the form 
$d(v)-\sum_is_i$, $d(v)-\sum_is_i-1$, or $d(v)-\sum_is_i+1$, where the 
sum is over some subset of $\{W_i\}_{i=1}^k$.  Consider the case where $q=d(v)-\sum_is_i-1$ on line \ref{line:fill2}, 
the other 
cases are similar.  Since this interval was assigned in the subroutine 
starting on line \ref{line:sr2}, both $a$ and $b$ are isolated arcs of $v$.  So $\sum_i s_i \le d(v)-2$, 
which implies $d(v)-2-\sum_is_i \ge 0$, and hence $q\ge 1$.

Next we show $r\le d(v)$.  By inspection of the procedure, 
$r$ is either $d(v)$, $d(v)-1$, $d(v)-2$, $d(v)-s_1$, $d(v)-s_1-s_k$, or $d(v)-s_i-1$.   However, since the size of a wedge 
is always positive, this is trivial.  

In all cases, $1\le p \le d(v)$, so this proves $(i)$.

To show $(ii)$, let $e=(v,u)$ and $e' = (v,u')$ be two arcs such that $u\ne u'$.  
Suppose that $e$ was assigned port 
$p$, and $e'$ was assigned port $p'$, by the Port-Numbering procedure.  If either of $p$ or $p'$ were assigned by the arbitrary-ports 
subprocedure, we are done since by definition these ports were chosen uniquely.  
Otherwise, both $p$ and $p'$ were assigned in the same subroutine 
of the Port-Numbering procedure, (since at most one subroutine is executed for each vertex).  
Notice that if $p$ and $p'$ are both ports in the same interval, then we are done since $u\ne u'$, (see  the definition of how 
intervals of ports are assigned to wedges).  


%Suppose $p$ and $p'$ do not both belong 
%to any single interval that was assigned in the Port-Numbering procedure.  
The five subroutines are disjoint, hence we consider them individually.  It is sufficient to show, for 
each subroutine, that every pair of intervals assigned is disjoint, 
and no port assigned outside of an interval is contained in some assigned interval.  This will imply that $p\ne p'$.  

Consider first the subroutine on line \ref{line:sr1}.  There is at most one interval assigned, and by line \ref{line:fill1}, the 
largest port in that interval is $d(v)-1$.  The port $d(v)$ assigned on line \ref{line:backtrack} is not 
contained in this interval.  Hence $p\ne p'$ since at most one of $p$ or $p'$ is contained in the interval, by supposition.

Next consider the subroutine on line \ref{line:sr2}, so the ports $d(v)-1$ and $d(v)$ were assigned on lines 
\ref{line:iso1} and \ref{line:iso2}, respectively.  There is at most one interval assigned in this subroutine, and by 
line \ref{line:fill2} the largest port contained in this interval is $d(v)-2$.   
  
Now consider the  subroutine on line \ref{line:sr3}.  
There were at most three intervals assigned, namely $[d(v)-s_1+1,d(v)]$, $[d(v)-s_1-s_k+1,d(v)-s_1]$, and $[d(v)-\sum_{i}s_i+1,d(v)-s_1-s_k]$, by 
lines \ref{line:bothout}, \ref{line:bothin}, and  \ref{line:fill3}, respectively.  
Clearly these are disjoint since 
$d(v)-s_1-s_k<d(v)-s_1-s_k+1<d(v)-s_1<d(v)-s_1+1$.   

The subroutine on line \ref{line:sr4} assigns port $d(v)-s_1$ on line \ref{line:onlya}, and at most two intervals.  
By lines \ref{line:outtied} and \ref{line:fill4}, we can clearly see that these intervals are disjoint and do not contain the port $d(v)-s_1$, 
since $d(v)-s_1-1<d(v)-s_1<d(v)-s_1+1$.

Finally, consider the subroutine on line \ref{line:sr5}.  So port $d(v)$ was assigned on line \ref{line:onlyb}.  There are 
at most two intervals assigned on lines \ref{line:intied} and \ref{line:fill5}.  These intervals clearly do not 
contain $d(v)$, and they are disjoint since $d(v)-s_k+1<d(v)-s_k$.  



Hence all cases, $p\ne p'$, so this proves $(ii)$.

To show $(iii)$, let $e=(v,u)$ be an arc of $\vec{G}$.  The Port-Numbering procedure will be executed at $v$ exactly once.  Hence the 
arc $e$ will be assigned a port by at most one of the five subroutines, 
(starting on lines \ref{line:sr1}, \ref{line:sr2}, \ref{line:sr3}, \ref{line:sr4}, and \ref{line:sr5}).  %The 
%conditions that invoke the subroutines are all exclusive, hence $e$ was considered by exactly one of them.  

If $e$ is not assigned a port in any of these five subroutines, then by definition that the 
arbitrary-ports subprocedure will always assign a port to $e$.  So $e$ always has at least one port number.


It remains to show that each subroutine assigns at most one port to $e$, (since they are exclusive).  %ndeed, if $e$ was assigned a 
%port outside of an interval, this is clear.  
If $e$ is an isolated arc of $v$, this is clear.  Furthermore, if 
$e$ was assigned a port outside of an interval, then $e$ is an isolated arc of $v$, see Lemma \ref{lemmaback}.  
We know $e$ belongs to at most one wedge by Lemma \ref{lemwedge}$(ii)$.  It is 
easy to verify in every that the length of each interval is equal to the size of the corresponding wedge (or wedges) that the interval 
was assigned to.  For example, the length of the interval on line \ref{line:fill1} is $d(v)-1 -(d(v) - \sum_i s_i) +1 = \sum_i s_i$.  

It only remains to show that each wedge is assigned at most one interval.  The only case where this may not be clear is in the subroutine 
on line \ref{line:sr3}.  
Let $a$ be the incoming arc of $v$, $b$ be the 
outgoing arc of $v$, and let $W_1,W_2,\ldots,W_k$ be the list of ordered wedges at 
$v$.  %Recall that only $W_1$ and $W_k$ can be tied wedges.  
By Lemma \ref{lemmaext}, $a^{-1}$ is a rib of the tied wedge $W_1$ and $b^{-1}$ is a rib of the died wedge $W_k$.  
We also know by Lemma \ref{lemboth}, that $W_1$ is not right tied and $W_k$ is not left tied, so $k\ne 1$.    Therefore each wedge is 
assigned at most one interval.   and $e$ has exactly one port number.  

\end{proof}


Now we know that the Port-Numbering procedure is well defined, and it produces a valid port numbering of the graph $\vec{G}$.  In the next section, 
we describe our mobile agent (robot) that will perform the traversal of $\vec{G}$ by using these ports.  



\subsection{The Robot}
\label{sec:robot}




In this section, we assume the graph $\vec{G}$ has a valid port numbering, as assigned by the Port-Numbering procedure.  
First we define a robot, that will visit vertices of the graph, and move between vertices 
along arcs.  We will define our robot to be a Mealy automata, similar to the work in \cite{GKMNZ}.  
Then we define an invariant that will show that the robot will visit 
each vertex of $\vec{G}$ in a periodic fashion after being placed on 
an arbitrary initial vertex.  

The robot is a type of finite automata called a Mealy automata, which is a five-tuple $M=(\Sigma,S,\alpha,v,T)$, 
where $\Sigma=[1,d(v)] \times V$ is the 
alphabet, $S = \{\alpha \}$ is the set of states, $\alpha$ is the initial state, $v$ is the initial vertex, 
and $T$ is the transition function.  The input and output of the transition function $T$ consists of one 
element of the alphabet, and one state; it is defined below. 


%During each step of the traversal, the robot will always be , and at one current vertex $v$.   
To \emph{leave} the current vertex $v$ on port number $p$, the robot will traverse the arc $e=(v,u)$ such that $e$ has the  
port number $p$.   
The robot then moves to the vertex $u$, and this vertex becomes the current vertex of the next step.  We also say that the robot \emph{entered}  
$u$ on the port $q$, where $q$ is the port number of $e^{-1}$.  Interestingly, this 
particular robot always stays in the initial state $\alpha$.  


The robot will always be in a given configuration $(p_1,v_1,\alpha)$, where $p$ is the entering port, $v$ is the current 
vertex, and $\alpha$ is the current state.  
It can examine all the arcs incident to $v$, and hence all the ports 
seen at $v$.  Using this information, the robot applies the transition function to decide which port it will leave the current vertex on, and which 
state to change to.  This ultimately also determines the next current vertex.  
The transition function is of the form $T((p_1,v_1),\alpha)=((p_2,v_2),\alpha)$, where 
$p_1$ is the entering port, $v_1$ is the current vertex, $p_2$ is the leaving port, 
$v_2$ is the new current vertex such that $v_2$ is the head of the arc incident to $v_1$ with port $p_2$.  For 
simplicity, we will wrote $T(p_1,v_1,\alpha)=(p_2,v_2,\alpha)$ instead of $T((p_1,v_1),\alpha)=((p_2,v_2),\alpha)$.  
We say that $(p_2,v_2,\alpha)$ is the new current configuration of the robot.  
Interestingly, this 
particular robot always stays in the initial state $\alpha$, however for formality, we include $\alpha$ 
in the configuration and the transition function.  
The transition function $T$ is defined as follows.  



\begin{eqnarray*}
T(p,v,\alpha)    &=& (q,u,\alpha) \mbox{ : } p < d(v), (v,u) \mbox{ has port }p+1, \mbox{ and } (u,v) \mbox{ has port } q\\
T(d(v),v,\alpha) &=& (q,u,\alpha) \mbox{ : } (v,u) \mbox{ has port } d(v)\mbox{ and } (u,v) \mbox{ has port } q
\end{eqnarray*}


Now we define an invariant which will guarantee, under certain conditions, that the robot will periodically traverse $\vec{G}$.  
Let $H^*$ be the directed graph constructed by starting from $H$, then replacing every virtual arc of $H$ with its 
corresponding relay path.  Naturally, $H^*$ induces a (directed) Hamiltonian walk of $\vec{G}$ by 
following $H$, where each virtual arc is traversed via the corresponding relay path.  
Hence $H^*$ is a subgraph of $\vec{G}$.  We will abuse 
notation and identify the directed graph $H^*$ with this Hamiltonian walk of $\vec{G}$, and denote both by $H^*$.  When 
we refer to a port number of an arc of $H^*$, we of course mean the port number of the corresponding arc of the graph $\vec{G}$.  
Observe that if $W$ is a wedge, then every 
rib of $W$ is in $H^*$.  This implies that the incoming and outgoing arcs of a vertex are always in $H^*$.  

The fact that $H^*$ is a Hamiltonian walk gives rise to the natural successor function defined 
on arcs of $H^*$; the \emph{successor} of an arc $e$ of $H^*$ is the arc following $e$ on $H^*$, denoted by $e^+$.  
In particular, if $e$ is the incoming arc of $v$, then $e^+$ is the outgoing arc of $v$, see for example Figure \ref{fig:iowedge}.  
With this in mind, we define an invariant which will 
guarantee, under certain conditions, that the robot will periodically traverse $\vec{G}$. \\

\noindent \textbf{The Invariant:} \emph{If the robot enters a vertex on an arc $e$ of $H^*$, 
then the robot will leave that vertex on the arc $e^+$ of $H^*$.  }\\

The invariant guarantees a periodic traversal once the 
robot uses an arc of $H^*$ to enter a vertex.  The fact that 
the invariant always holds follows from Lemma \ref{lemmainvariant}.  First, we first prove that, given 
the correct initial configuration with any initial vertex, the robot always 
leaves the vertex on an arc of $H^*$, and hence enters the new current vertex on an arc of $H^*$.  

\begin{figure}[htp] 
\begin{minipage}[b]{0.5\linewidth}
\centering 
\includegraphics[width=6cm]{bothisoh.pdf}
\newline
$(i)$
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.5\linewidth}
\centering
\includegraphics[width=6cm]{bothiso.pdf}
\newline
$(ii)$
\end{minipage}
\caption[The incoming and outgoing arcs of a vertex are both isolated]{Both $a$ and $b$ are isolated arcs of $v$.  Represented are two 
of the four possible configurations, depending on whether or not $a$ or $b$ are arcs of $H$.
In $(i)$ we depict the case where both $a$ and $b$ are arcs of $H$; in $(ii)$ we depict the case 
where neither $a$ nor $b$ are arcs of $H$. \label{fig:bothiso}}
\end{figure}



\begin{lemma}\label{lemmastart}
Let $v$ be any vertex of $G$.  Suppose the robot starts on the configuration $(d(v),v,\alpha)$.  
Then the robot will leave $v$ on an arc $e$ of $H^*$.  Hence if $e=(v,u)$, the robot will enter 
$u$ on an arc of $H^*$.
\end{lemma}
\begin{proof}  

%Suppose that the robot is placed at the initial vertex $v$.    
Let $a$ be the incoming arc of $v$, $b$ be the 
outgoing arc of $v$, and suppose that $v$ is the relay vertex of $k\ge 0$ distinct wedges.  
%Only case $(1)$ of the transition function can be applied here, since the robot will be in the initial state $\alpha$.  
Since the configuration has the entering port $d(v)$, the second case of the transition function will be applied.  Hence it is sufficient 
to show that the Port-Numbering procedure has assigned port $d(v)$ to an arc with tail vertex $v$, that is an arc of $H^*$.  
Recall that $H^*$ contains both $a$ and $b$, as well as 
any arc that is a rib of any wedge.  
There are five cases based on the subroutines of the Port-Numbering procedure. 



\noindent\textbf{Case 1: } Suppose first that $a=b^{-1}$.    
So the subroutine on line \ref{line:sr1} 
was executed $v$.  Port $d(v)$ was assigned to $b$ by line 
\ref{line:backtrack}, which is an arc of $H^*$.  

From now on, suppose $a\ne b^{-1}$.

\noindent\textbf{Case 2: } Suppose that both $a$ and $b$ are isolated arcs of $v$; for example 
see Figure \ref{fig:bothiso}.  
So the subroutine on line \ref{line:sr2} was executed at $v$.  So 
$b$ has port $d(v)$ by line \ref{line:iso2}.  


\noindent\textbf{Case 3: } Now suppose neither $a$ nor $b$ are isolated arcs of $v$; 
see Figure \ref{fig:noneiso}.  So the subroutine at line \ref{line:sr3} was executed at $v$.    
By line \ref{line:bothout}, the right external rib of $W_1$, (which is an arc of $H^*$), has port $d(v)$.  
 

\noindent\textbf{Case 4: } Now suppose $b$ is not an isolated arc of $v$, and $a$ is an isolated arc of $v$, for 
the two possible cases see Figure \ref{fig:onlyai}.  
So the subroutine at line \ref{line:sr4} was executed at $v$.    
Hence the right external rib of $W_1$, (which is an arc of $H^*$), was assigned port $d(v)$ by line \ref{line:outtied}.  


\noindent\textbf{Case 5: } Finally suppose $a$ is not an isolated arc of $v$, and $b$ is an isolated arc of $v$, 
so the subroutine at line \ref{line:sr5} was executed at $v$.  For the two possible cases see Figure \ref{fig:onlybi}.
By line \ref{line:onlyb}, $b$ has port $d(v)$.

\end{proof}

\begin{figure}[htp] 
\begin{minipage}[b]{0.5\linewidth}
\centering 
\includegraphics[width=6cm]{onlyaisoh.pdf}
\newline
$(i)$
%\caption{Non isolated arcs with a tied wedge\label{fig:athbr}} 
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.5\linewidth}
\centering
\includegraphics[width=6cm]{onlyaiso.pdf}
\newline
$(ii)$
%\caption{Non isolated arcs without a tied wedge}
\end{minipage}
\caption[The incoming arc of a vertex is isolated]{The arc $a$ is an isolated arc of $v$, and $b$ is not.  In figure $(i)$, $a$ is an 
arc of $H$, and in figure $(ii)$ it is not.  \label{fig:onlyai}}
\end{figure}



Now we know that at the initial step, the robot always enters the new current vertex along an arc of $H^*$.  
The following lemma implies that the invariant always holds, provided that the robot entered a vertex $v$ on an arc of 
$H^*$, (and is configuration $(p,v,\alpha)$).  


\begin{lemma}\label{lemmainvariant}
Suppose the current configuration of the robot is $(p,v,\alpha)$, such that $v$ was entered on 
an arc $e$ of $H^*$.  Then the robot will leave on $e^+$, (which is an arc of $H^*$).  
%Let $v$ be the current vertex of the robot, $\alpha$ be the current state of the robot, and suppose 
%the robot entered $v$ along the arc $e$ of $H^*$.  Then 
%the robot will leave $v$ on $e^+$.
\end{lemma}
\begin{proof}

Let $e=(u,v)$, hence $p$ is the port number of $e^{-1}=(v,u)$.  
Suppose $T(p,v,\alpha)=(q,v',\alpha)$, so the robot leaves $v$ on the arc $(v,v')$, and the port of $(v',v)$ is $q$.  
It is sufficient to show that $e^+=(v,v')$.  


%, such that its 
%reverse $(v',v)$ has port $q$.
%Hence 
%it is sufficient to show that the arc $e^+=(v,v')$ has port $q$ such that $T(p,v,\alpha)=(q,v',\alpha)$.  
%Since the vertex $v'$ is implied whenever 
%the arc $e^+$ is defined, and since the robot will never leave state $\alpha$, we will abuse notation and write 
%$T(p,e)=(q,e^+)$ to represent $T(p,v,\alpha)=(q,v',\alpha)$.


Let $a$ be the incoming arc of $v$, $b$ be the outgoing arc of $v$, and $v$ 
be the relay vertex of $k\ge 0$ wedges.  First notice that, since the tail of $b$ is $v$, 
$e\ne b$, and similarly $e$ is not the right external rib of any wedge 
with relay vertex $v$.  Hence we can see that either $e=a$, or $e$ is an internal rib, or the left external rib of some wedge with 
relay vertex $v$.%, (indeed, if $e$ is either an arc of $H$ or a rib of some wedge with relay vertex $u$, then $e=a$).  

%The proof is laid out in five cases, each of which considers one subroutine 
%of the Port-Numbering procedure, and examines all the possible values of $p$.

In what follows we will examine all possible values for the port $p$.  This will 
be done with respect to each of the five subroutines of the Port-Numbering procedure, (since the 
subroutines are exclusive, and we know $p$ was assigned in one of these subroutines since $e$ is an arc of $H^*$).  

\begin{figure}[htp] 
\centering
\resizebox{6cm}{!}{\includegraphics{noneiso.pdf}}
\caption[Neither the incoming nor outgoing arcs of a vertex are isolated]{Neither $a$ nor $b$ are isolated arcs of $v$.\label{fig:noneiso}}
\end{figure}



\noindent\textbf{Case 1: } Suppose first that $a=b^{-1}$, see Figure \ref{fig:wedgebkt}.  
So the subroutine on line \ref{line:sr1} was executed at $v$.  
By line \ref{line:backtrack}, the port of $a^{-1}=b$ is $d(v)$.  Hence if $p=d(v)$, then $e=a$, which implies 
$e^+=b$.  
Since the port of $e^+$ is $d(v)$, $e^+=(v,v')$.  
%v),e)=(d(v),e^+)$, (so the robot will leave $v$ on $e^+$).  %So the robot will leave $v$ on $e^+$.  

Now let $p< d(v)$.  %This implies, from line \ref{line:fill0}, that 
Since the port of $a^{-1}$ is $d(v)$, $e\ne a$.  Since $e$ is an arc of $H^*$, and $e\ne a$, it follows that 
$e$ is a rib of some wedge with relay 
vertex $v$, and hence $k>0$.  Let $W_1,W_2,\ldots,W_k$ be the list of ordered wedges at 
$v$.  So $e$ is a rib $W_j$ for some $1\le j\le k$.  %By line line \ref{line:fill1}, $p\le d(v)-1$.  
Furthermore, since $e$ is not 
the right external rib of $W_j$, there is a virtual arc 
$(u,x)$ of $W_j$ such that $e^+=(v,x)$ is a rib of $W_j$.  Clearly, $e^+$ was assigned port $p+1$ at $v$ by line \ref{line:fill1}.  
Since $p< d(v)$, $x=v'$ and hence $e^+=(v,v')$.

From now on, suppose $a\ne b^{-1}$.  

\begin{figure}[htp] 
\begin{minipage}[b]{0.5\linewidth}
\centering 
\includegraphics[width=6cm]{onlybisoh.pdf}
\newline
$(i)$
%\caption{Non isolated arcs with a tied wedge\label{fig:athbr}} 
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.5\linewidth}
\centering
\includegraphics[width=6cm]{onlybiso.pdf}
\newline
$(ii)$
%\caption{Non isolated arcs without a tied wedge}
\end{minipage}
\caption[The outgoing arc of a vertex is isolated]{The arc $b$ is an isolated arc of $v$, and $a$ is not.  In figure $(i)$, $b$ is an 
arc of $H$, and in figure $(ii)$ it is not.  \label{fig:onlybi}}
\end{figure}




\noindent\textbf{Case 2: } Suppose both $a$ and $b$ are isolated arcs of $v$, see Figure \ref{fig:bothiso}.  
So the subroutine on line \ref{line:sr2} was executed at $v$.  
If $p=d(v)-1$, then $e=a$ by line \ref{line:iso1}, which implies $e^+=b$.  
Since $b$ has port $d(v)$ by line \ref{line:iso2}, $e^+=(v,v')$. %the robot will leave $v$ on $e^+$ by the transition function.  


Now let $p\ne d(v)-1$.  This implies $e\ne a$, and hence 
$e$ is a rib of some wedge with relay vertex $v$, which means $k>0$.    
Let $W_1,W_2,\ldots,W_k$ be 
the list of ordered wedges at $v$.  Let $e$ is a rib of $W_j$ for some $1\le j\le k$. 
Since the head of $e$ is $v$, $e$ is either an internal rib or the left external rib of $W_j$.  
So $e^+ = (v,x)$ where $(u,x)$ is a 
virtual arc of $W_j$.   
We know by by line \ref{line:fill2} that $e^+$ has port $p+1$, and $p<d(v)$.  Therefore $x=v'$, so $e^+=(v,v')$.
%the robot will leave $v$ on $e^+$ by the transition function.  

  
\noindent\textbf{Case 3: } Suppose that neither $a$ nor $b$ are isolated arcs of $v$, see Figure \ref{fig:noneiso}.  This implies 
that the subroutine on line \ref{line:sr3} was executed at $v$.  This also implies that $k\ge 1$, so let 
$W_1,W_2,\ldots,W_k$ be the list of ordered wedges at $v$.  
Hence, by Lemma \ref{lemmaext}, $a^{-1}$ is the right external rib of $W_j$, 
and $b^{-1}$ is the left external rib of $W_{j'}$, for $1\le j,j' \le k$.  Furthermore, since $W_j$ is right tied and 
$W_{j'}$ is right tied, $j=k$ and $j'=1$.  
Hence $b$ has port $d(v)-s_1+1$, and $a^{-1}$ has port $d(v)-s_1$, 
by lines \ref{line:bothout} and \ref{line:bothin}, respectively.  %Notice 
%that $p \le s_j < d(v)$, so only the transition function is applicable.  

Suppose $p=d(v)-s_1$, so $e=a$ and $e^+=b$.  
Since $e^+$ has port $p+1=d(v)-s_1+1$, and since $p<d(v)$, $e^+=(v,v')$. 

Next suppose $p\ne d(v)-s_1$, which implies $e\ne a$.  Thus $e$ is either an 
internal rib or the left external rib of some wedge $W_j$ for $1\le j\le k$.  Thus $v$ is the relay vertex of a virtual arc $(u,x)$ of $W_j$, such 
that $e^+=(v,x)$.  So port $p+1$ was assigned to $e^+$ (by either line  \ref{line:bothout}, \ref{line:bothin}, or \ref{line:fill3}).  
Therefore $x=v'$, hence $e^+=(v,v')$.   


\noindent\textbf{Case 4: } Next, we suppose that $b$ is not an isolated arc of $v$, and $a$ is an isolated arc 
of $v$, see Figure \ref{fig:onlyai}.  %, for example see Figure \ref{fig:onlyai}.    
So the subroutine at line \ref{line:sr4} was executed at $v$.  Since $b$ is not an isolated arc of $v$, we have $k>0$, 
so let $W_1,W_2,\ldots, W_k$ be 
the list of ordered wedges at $v$.  By Lemma \ref{lemmaext}, $b^{-1}$ is the left external rib of $W_j$ for some $1\le j\le k$.  Since 
$W_j$ is a left 
tied wedge, $j=1$.    

If $p=d(v)-s_1$, then $e=a$, which implies 
$e^+ = b$.  By line \ref{line:outtied}, $e^+$ has port $d(v)-s_j+1=p+1$, so $e^+=(v,v')$.  
%by the transition function, the robot will leave $v$ on $e^+$.  

Otherwise $p\ne d(v)-s_1$, so $e\ne a$.  Hence $e$ is a rib of some wedge $W_j$ with relay vertex $v$, where $1\le j\le k$.  
Since $e$ is not the right external rib of $W_j$, we have $p<d(v)$. 
As above, $e^+$ is a rib of $W_{j}$ such that $e^+$ has port $p+1$, either by line \ref{line:outtied} 
or \ref{line:fill4}.    
Therefore $e^+=(v,v')$.  
%by the transition function, 
%the robot will leave $v$ on $e^+$.

\noindent\textbf{Case 5: } Now suppose that $b$ is an isolated arc of $v$ and $a$ is not, see Figure \ref{fig:onlybi}.  So 
the subroutine on line \ref{line:sr5} was executed at $v$.  
Since $a$ is not an isolated arc of $v$, $k>0$, so let $W_1,W_2,\ldots,W_k$ be the list of ordered wedges at $v$.  By 
Lemma \ref{lemmaext}, 
$a^{-1}$ is the right external rib of $W_k$.  By line \ref{line:intied}, $a^{-1}$ has 
port $d(v)-1$.  

If $p=d(v)-1$, then $e=a$, which 
implies $e^+ =b$.  Since $e^+$ has port $p+1=d(v)$ by line \ref{line:onlyb}, $e^+=(v,v')$. 
%by the transition function the robot will leave $v$ on $e^+$.  

Now suppose $p\ne d(v)-1$.  
So $e$ is either an internal rib, or the left external rib of $W_j$, for some $1\le j\le k$.  As in previous cases, 
$e^+$ is the rib of $W_j$ that has port $p+1$ by either line \ref{line:intied} or \ref{line:fill5}, 
(and it is clear that $p<d(v)$).  Thus $e^+=(v,v')$. 
%the robot will leave $v$ on $e^+$ by the transition function.



 
In all five cases, the robot left $v$ on the arc $e^+$ according to the transition function.  
The proof of the invariant follows.





\end{proof}

%\newpage
\subsection{Upper Bound of the Period} 

 We obtain an upper bound on the period of this traversal.  
 


\begin{theorem}
Let $G$ be a $2$-connected, $P_3$-free graph, and $H$ be a Hamiltonian cycle of $G^2$ with the minimal number of virtual arcs.  
If the ports of $G$ are assigned according to the Port-Numbering procedure, then the 
robot will perform a periodic traversal of $G$ with period $\pi (n) \le 2n-2$, provided it starts in configuration $(d(v),v,\alpha)$, 
where $v$ is any vertex of $G$.
\end{theorem} 
\begin{proof} 
 
The result in \cite{FL}, which is now known as Fleishner's theorem, that $H$ exists.  Suppose $H^*$, the robot, and the ports of $G$ 
are as described above.  
By Lemma \ref{lemmastart}, the robot will leave $v$ on an arc of $H^*$.  After this step, by 
Lemma \ref{lemmainvariant}, the robot will start periodically traversing arcs of $H^*$.  
Hence it is enough to estimate 
the period of the traversal, $\pi(n)$.  
Recall that the period $\pi(n)$ of the traversal 
is the maximum number of arc traversals between two consecutive visits of any vertex.  
For any arc $e=(u,v)$ of $H$, the robot will traverse at most two arcs to get from $u$ to $v$; one if $e$ 
is real and two if $e$ is virtual.  The maximum number of arc traversals between two visits of $v$ will clearly occur 
when the robot traverses the entire walk $H^*$ after leaving $v$.  Suppose that $H$ has $i$ virtual arcs, and $j$ real arcs, 
where necessarily $i+j=n$.  Thus the maximum number of arcs of $H^*$ (and hence of $G$) traversed is $2i+j$.  
It was shown in \cite{G}, (which is a short constructive proof of Fleishner's theorem), that for every $2$-connected 
graph $G$, $G^2$ has a Hamiltonian cycle that uses at least two edges of $G$.  Since $H$ 
was chosen to have the minimal number of virtual arcs, $j\ge 2$.  So we maximize $2i-j$ by setting $i=n-2$, to obtain 
$\pi(n)\le 2(n-2)+2 = 2n-2$.  
 
\end{proof} 

%...
%\begin{comment}
\newpage
\section{Geometric Graph Traversal} %%%%%%%%%%%%%%%%  1
\label{sec-geo}


%The problem of \emph{graph traversal} is fundamental problem in graph theory, and it has applications in network discovery and 
%route optimization.  Given an unknown graph and a starting 
%vertex, can the graph be systematically traversed reaching every vertex from the starting one?  It is very useful, but not 
%neccessary, that the graph be vertex labelled, that is, we are able to distingush between two different vertices.  In this thesis 
%we are only dealing with labelled graphs.  

In this section, we let $G$ be a finite graph with $n$ vertices and $m$ edges 
that is not anonymous, i.e., every vertex has a unique identifier drawn from set 
of labels.  For example, each vertex could be assigned a unique number from the set $\{1,2,\ldots,n\}$.  Hence an algorithm on such a 
graph that uses these labels must use at least $O(\log n)$ bits of memory.  
Recall that a solution to the graph traversal problem is an algorithm that will start at any vertex of $G$, and will eventually halt after 
every vertex of $G$ has been visited.  Notice how this differs from a periodic traversal, where each vertex must be visited infinitely many 
times in a periodic manner.  


In this section, we provide a traversal algorithm that can start with any vertex of the graph.  
Our solution is an algorithm that visits edges instead of vertices, and will output a list containing each edge exactly once.  Edges 
are reported to this list in some order as they are visited, (not neccessarily the first time), 
which implies every vertex has been visited.  
The traversal is based on two concepts of the graph 
which we will define, called an oriented walk cover, and a compatible total order.  %We will assume an embedding 
%of our graph into a surface, and the algorithm will use the corresponding geometric information.  
These concepts are inspired 
by faces of a planar graph, and the geometric information of edges and vertices in an embedding of the graph.  Then, we will define 
an auxilliary graph called the virtual tree, which is used to prove the correctness of our algorithm.  We show that 
our algorithm will traverse any graph $G$ with these two concepts in $O(m\log m)$ time and $O(\log n)$ memory, where $G$ has $m$ edges 
and $n$ vertices.  

Finally, we will assume the graph has a $2$-cell embedding on some surface, and show that the two concepts described above 
can be obtained.  
We conclude that this traversal algorithm can be applied to any finite geometric graph.  

reference best existing result, planar etc.




%We say that a traversal algorithm uses \emph{no extra memory} if the upper bound of the memory requred is $O(\log(n))$
%A 
%polynomial time graph traversal for arbitrary graphs given by \cite{} uses $O(\log^2(n))$ memory.  This memory bound has 
%recently been improved to $O(\log^{3/2}(n))$ memory in \cite{}, however it uses a non-polynomial time algorithm.
%In this section, we provide a routing algorithm for geometric graphs that uses no extra memory.  Recall that a 
%geometric graph is a 
%graph along with an embedding in $\mathbb{R}^3$, where each vertex has unique cartesian coordinates.  
%This method is based  on previous work by ~\cite{} and 
%~\cite{}, which provided similar results for planar, quasi planar, and polyhedral graphs.  %


%
%Recall that $2$-cell embedding places the vertices and edges of the graph on 
%a surface of genus $g$.  While it was shown in \cite{} that the genus for a given graph is NP-hard, there 
%are constructive polynomial time algorithms that produce such an embedding, if the genus is known, see \cite{}.  
%More recently, it was shown in 
%\cite{MOHAR} that such an embedding can be computed in linear time.  This shows that our algorithm 
%will traverse every geometric graph.  
% However this polynomial algorithm uses $O(f)=O(n)$ memory in the worst case, since in the worst case we 
%need one pebble per face.  



%\subsection{Previous Results}
%\label{ss-pr}
%...
\begin{comment}
\subsection{Model of Computation}
\label{ss-moc}

This section describes the model of computation the algorithm will use, which will be important 
to show that no extra space is required.  Any graph theory problem requires $\Omega(\log n)$ memory, 
since $n$ vertices must be stored using binary labels.  We say a graph algorithm uses \emph{no extra memory} if uses 
$O(\log n)$.  

The model of compuatation used in this paper is a variation of the Jumping 
Automaton for Graphs or JAG first used by Cook and Rackoff[bibtex citation here].  This setting makes 
sense because it has been shown [citation needed] since that the JAG is an equivalent model to the Turing 
machine for undirected graph theoretic problems.  Conceptually, 
the JAG can be thought of as a multi-head Finite State Automata, 
where each head (represented by a pebble) is on one vertex, and each move of the JAG can move one head.  

The initial state of a JAG will have all pebbles on the start vertex, and the machine 
will be in the initial state.  One move of the JAG will, according to 
its transition function, change its state and move one pebble.  
A pebble can be either walked to an adjacent vertex 
to the current one, or it can be jumped to any other vertex that already has a pebble.  The running 
time of a JAG is the number of pebble moves that are made, and the memory required is $P \log n+\log Q$, 
where $P$ is the number of pebbles and $Q$ is the number of states.  So as long as $P$ is a constant, 
and $Q = n^{O(1)}$, then the JAG will requre no extra space.  

Our variation of the JAG has two differences.  The first is that we need one \emph{agent} that will move 
around the graph, and it will rest on edges instead 
of vertices.  To simulate this, we have two designated \emph{agent pebbles} that will be placed on the endpoints of the 
current edge.  In the case of a directed graph, the pebbles will be labelled as head or tail pebbles.  All other pebbles 
will be \emph{stationary} pebbles; they can be dropped or removed from the current location.  
\end{comment}

%\subsection{Traversal of Embedded Geometric Graphs}   %%%%%%%%%%%%%%%% 2
%\label{sec-embed}

%In the paper by 
%[reference] the faces of a quasi-planar graph were used to 
%traverse the graph by building a virtual tree where each face 
%in the tree is represented as a vertex in the virtual tree.  The same paper also derives from the planar embedding 
%a total order on the edges with some useful properties.  In this setting, they give a traversal algorithm 
%that uses no extra memory.  
%First, section\ref{ss-prelim} below defines two notions that generalizes each 
%of these structures, and then section\ref{ss-basicfunctions} describes all the basic functions 
%used in the algorithm.  

\subsection{Covering Walks and a Compatible Total Order}
\label{ss-prelim}

Let $G$ be an undirected, finite, simple graph, and let $\vec{G}$ be its symmetric orientation.  Recall that $\vec{G}$ replaces each  
edge $uv$ in $G$ by the pair of arcs $(u,v)$ and $(v,u)$, and that we refer to the 
reverse of $e= (u,v)$ by $e^{-1} = (v,u)$.  

%First, we generalize the idea of faces in a planar or quasi-planar graph.%, we use a structure that is 
%based on an \emph{oriented cycle double cover} that uses walks instead of cycles.

\begin{definition}
\label{def-ocw}
An oriented walk cover $W$ of $\vec{G}$ is a collection of closed walks from $\vec{G}$ such that 
each arc $e$ of $\vec{G}$ is in exactly one walk $w\in W$.  We call 
$w$ a covering walk of $\vec{G}$.
\end{definition} 

It is clear that any oriented walk cover of $\vec{G}$ is finite, since $G$ is finite.  We say the size 
of a covering walk $w$, denoted $|w|$, is the number of arcs of $w$.  
Next we define a special total order on the arcs of $\vec{G}$ such that any arc and its reverse are consecutive in the total order.

\begin{definition}
\label{def-compatible}
Let $G$ be an undirected graph, and suppose $\vec{G}$ has a total order on its arcs.  
We say this total order is compatible if for 
any arc $e$ of $\vec{G}$, there does not exist an arc $e'$ 
such that either $e<e'<e^{-1}$ or $e^{-1} < e' < e$.
\end{definition}

From now on, suppose $\vec{G}$ has a compatible total order, and an oriented walk cover $W$.  Every total 
order over a finite set has a unique minimal element, hence we denote the minimal arc of $\vec{G}$ by $e_0$.  
Furthermore, for every covering walk $w$ of $\vec{G}$, there is a minimal arc with respect to this total order restricted to the 
arcs of the walk $w$.  We call this arc the \emph{entering arc} of $w$.  
%We denote the minimal arc in the 
%entire graph $G$ by $e_0$.  %In a planar embedding of a graph, we can induce a total order on the arcs 
%based on the coordinates of the vertices; which means that any arc and its reverse will be 
%adjacent in the partial order since they have the same endpoints.  We generalize this property, as well 
%as restricting it so that the minimal arc is the only one whose reverse is also an entering arc.


We will now proceed to define several functions that use $O(\log n)$ memory.  
For any arc $e$, we say $\cwalk(e)=w$ if $w$ is the unique covering walk containing $e$.   
If $e=(u,v)$, let $\rev(e)=e^{-1}$, $\head(e)=v$, and $\tail(e)=u$.   
Next define the predecessor function $\pred(e)=f$ if and only if $f$ is in $\cwalk(e)$ and $\head(f)=\tail(e)$.  
Similarly, the successor function $\suc(e)=f$ if and only if $f$ is in $\cwalk(e)$ and $\tail(f)=\head(e)$.  


Given any covering walk $w$ we say $\entry(w)=e$ if $e$ is the entering 
arc of $w$.  We compute this using the algorithm from \cite{BM}, which was also used in \cite{CDKOSU}.  For convenience 
we give this algorithm below.  Recall that our traversal algorithm uses a mobile agent that visits 
one arc of $\vec{G}$ at a time.  Initially, the current arc of the algorithm is $e$, and the algorithm makes two 
copies of the mobile agent.  These two agents move clockwise and counter-clockwise, respectively.  The algorithm halts whenever a smaller 
arc is found, or when the two agents run into each other.  At the end, these two cloned agents can be removed, and the traversal can 
be resumed using the original mobile agent on the arc $e$.  



\begin{center}\begin{tabular*}{\textwidth}{c}\hline\end{tabular*}\end{center}
\noindent \textbf{Algorithm entry}$(w)=e$
\begin{algorithmic}[1]
\STATE {$e^{cw} \leftarrow e$}
\STATE {$e^{ccw} \leftarrow e$}
\REPEAT
 \STATE {$e^{cw} \leftarrow \pred(e^{cw})$}
    \IF{$e^{cw} = e^{ccw}$}
       \STATE{\textbf{return} true}
  \ELSE
     \IF {$e^{cw}<e$}
          \STATE{\textbf{return} false}
     \ENDIF
\ENDIF 


 \STATE {$e^{ccw} \leftarrow \suc(e^{ccw})$}
    \IF{$e^{cw} = e^{ccw}$}
       \STATE{\textbf{return} true}
  \ELSE
     \IF {$e^{ccw}<e$}
          \STATE{\textbf{return} false}
      \ENDIF
   \ENDIF 

\UNTIL{TRUE}
\end{algorithmic}
\begin{center}\begin{tabular*}{\textwidth}{c}\hline\end{tabular*}\end{center}

This algorithm will always halt, since $w$ is a closed walk.  
The correctness of the $\entry$ is easy to check, since it only returns true after it has compared the given arc 
$e$ to every other arc of the walk.  If $\entry(e)$ returns false, then there is some arc $e'$ such that $e'<e$.  Since only three 
mobile agents are needed, we can say this algorithm uses a constant number of mark bits, (or pebbles), hence at most 
$O(\log n)$ memory is required.  The purpose of using this method is that it has sublinear running time, as opposed to 
simply traversing the walk in only one direction which takes $O(n)$.  The running time of this algorithm follows from 
the following Lemma from \cite{BM}, which we repeat here along with the proof.  This lemma was originally given in terms of 
faces of a planar graph, instead of closed walks, however the result still holds.  


\begin{lemma}\label{hme}
\cite{BM}  Let $e_1,e_2,\ldots,e_{|w|}$ be the arcs of the covering walk $w$ in order.  We say that $e_i$ is $k$-minimum if $e_i\le e_j$ for all 
$i-k\le j\le i+k$, where subscripts are taken mod$|w|$.  We define $mk(e_i)$ as the maximum $k$ for which $e_i$ is $k$-minimum.  Then 

$\sum_{i=1}^{|w|} mk(e_i) \le |w| \ln |w|$.
\end{lemma}
\begin{proof}
If $e_i$ is $k$-minimum, then none of $e_{i-k},\ldots, e_{i-1},e_{i+1},\ldots, e_{i+k}$ are 
$k$-minimum.  Therefore, at most $\lfloor |w|/(k+1) \rfloor$ arcs of $w$ are $k$-minimum.  Thus, 

\begin{displaymath}
\sum_i mk(e_i) = \sum_{k=1}^{|w|} |\{e_i \: : \: e_i \mbox{ is } k\mbox{-minimum} \} | 
\le  |w| \sum_{k=1}^{|w|} \lfloor  1/ (k+1) \rfloor 
\le |w| \ln |w|,
\end{displaymath}

where the final step follows since $\sum_{i=1}^x 1/x \le \ln x+1$.  

\end{proof}






The traversal algorithm will start by traversing some current covering walk.  
Next, we define a relationship between certain covering walks.  We define $\parent(w) = \cwalk(\rev(\entry(w)))$, provided that $e_0\ne \entry(w)$.  
Hence, if $e$ is the entering arc of $w$, and $e\ne e_0$, then $e^{-1}$ is an arc of the covering walk $\parent(w)$.  
The idea of the next lemma is to show that this parent function is decreasing, i.e., it produces a walk with a smaller 
entering arc.  
%Hence, if for some covering walk $w$, $e$ is an arc of $\parent(w)$, 

\begin{lemma}  
\label{lemparent}
If $w\in W$ such that $e_0\ne \entry(w)$, and we suppose $\entry(\parent(w))\ne \rev(\entry(w))$, then $\entry(\parent(w)) < \entry(w)$.  
\end{lemma}
\begin{proof} 
Let $e_w = \entry(w)$ and $e_p = \entry(\parent(w))$.  Notice that since $e_p$ and $e_w$ are in different walks, 
$e_p \ne e_w$, and $e_p\ne e_w^{-1}$ by supposition.  

Suppose to the 
contrary that $e_w <e_p$.  We know $e_p < e_w^{-1}$, since 
$e_p$ is the entering arc of $\parent(w)$.  But now $e_w < e_p < e_w^{-1}$, a contradiction since 
we supposed the total order is compatible.  
\end{proof}


%So the robot can find the entering arc of the current walk.  Next we need to determine if 
%any given arc is the minimal arc $e_0$.

Next we define a function that is able to determine whether any given arc is the minimal arc $e_0$, without comparing the given arc 
to every other arc of $\vec{G}$.  
Define function $\ismin(e)$ to return true if and only if the following three conditions are satisfied:
\begin{itemize}
\item $e = \entry(\cwalk(e))$
\item $e^{-1} = \entry(\cwalk(e^{-1}))$
\item $e < e^{-1}$
\end{itemize}


Next we prove the correctness of the $\ismin()$ function.

\begin{lemma}
\label{lemismin}
The function $\ismin(e)$ returns true if and only if $e=e_0$.
\end{lemma}
\begin{proof}
Let $e$ be an arc of $\vec{G}$.  Suppose $\ismin(e)$ returns true, i.e., its three 
conditions are satisfied.  Suppose to the contrary 
that $e_0 \ne e$, which implies $e_0<e$.  Let $w=\cwalk(e)$, and $e_p = \entry(\parent(w))$.  By definition, 
$\parent(w) =\cwalk(\rev(\entry(w))) = \cwalk(e^{-1})$.  This implies $e_p = \entry(\cwalk(e^{-1})) =e^{-1}$, 
by the second condition of $\ismin(e)$.  Since $e=\entry(w)$, it follows 
from Lemma \ref{lemparent} that $e_p=e^{-1} < e$.  This is a contradiction, since we supposed $e<e^{-1}$.  
 
Now we suppose $e=e_0$ and show $\ismin(e)$ must return true.  
It is clear that $e<e^{-1}$ and $e = \entry(\cwalk(e))$.  Let $e'=\entry(\cwalk(e^{-1}))$.  Suppose 
to the contrary that $e'\ne e^{-1}$, which implies $e'<e^{-1}$.  But now $e < e' < e^{-1}$, which is a contradiction since this is a compatible total order. 
\end{proof}




\subsection{Virtual Tree}
\label{ss-virtualtree}



The main idea of the traversal algorithm is to traverse every covering walk, and switch between covering 
walks using these entering arcs.  Now we define a virtual tree, which is inspired 
by the idea of the dual of a planar graph.  
This virtual tree will use covering walks as vertices, and consider two walks to be adjacent whenever one walk is the parent of the other.  



Given the oriented walk cover $W$ of $\vec{G}$, we construct an auxiliary graph $G(W)$ called the \emph{virtual tree}.  
Define $G(W)=(W,E(W))$ where $E(W) = \{(w,w') \: : \: \parent(w) = w' \}$.  We will consider the walk containing $e_0$ to be the 
root of the virtual tree.    
We next show that $G(W)$ is a tree by showing it is acyclic and connected.  

\begin{lemma}
\label{lemtree}
$G(W)$ is a tree with root $\cwalk(e_0)$. 
\end{lemma}
\begin{proof}

Let $w\in W$, and let $w_0 = \cwalk(e_0)$.  It is sufficient to show there 
is a unique path in $G(W)$ from $w$ to $w_0$.  
First, notice that there cannot be more than one path from 
$w$ to $w_0$, since each walk has exactly one entering arc.  

Suppose to the contrary that there is no path from $w$ to $w_0$.  
Consider the sequence $w_1 = \parent(w)$, $w_2 = \parent(\parent(w))$, and so on.  So $w_i \ne w_0$ for 
all $i>0$ by assumption.  Since $\entry(w_0)=e_0$, we have $\entry(w_i) > \entry(w_0)=e_0$ for all $i>0$.  


We will use Lemma \ref{lemparent}, which means we must show 
$\entry(\parent(w_i))$ and $\rev(\entry(w_i))$ are not equal for all $i>0$.  Suppose to the contrary that 
$\entry(\parent(w_i)) = \rev(\entry(w_i))$ for some $i$.  
Let $e=\entry(w_i)$, so by assumption $e^{-1}= \entry(\parent(w_i))$.  Therefore the 
first two conditions of $\ismin()$ are satisfied.  Since $e\ne e^{-1}$, we have either $e<e^{-1}$ or $e^{-1}<e$.  Therefore 
either $\ismin(e)$ or $\ismin(e^{-1})$ returns true.  This contradicts \ref{lemismin}, since none of $w_i$, in particular $\cwalk(e)$ 
or $\cwalk(e^{-1})$, are $w_0$.    
We conclude that $\entry(\parent(w_i)) \ne \rev(\entry(w_i))$, so by Lemma~\ref{lemparent}, 
$\entry(w_{i+1}) < \entry(w_i)$ for all $i>0$.  Hence, the infinite sequence $w_1,w_2,w_3,\ldots$ is 
a strictly decreasing sequence that is bounded below by $\entry(w_0)$.  
This is a contradiction since $\vec{G}$ and $W$ are finite.  Therefore there is exactly one path in $G(W)$ from $w$ to $w_0$, and hence $G(W)$ 
is a tree with root $\cwalk(e_0)$.
\end{proof}

The traversal algorithm is given in the next section. % It simulates 
%a traversal of the virtual tree, which will ensure that every covering walk is entered at least 
%once.  Furthermore, the algorithm will visit every arc of each walk of $W$, which ensures that 
%every vertex will be visited.

\subsection{Traversal Algorithm}
\label{ss-algorithm}

%The algorithm given in this section requires a graph $\vec{G}$, an oriented walk cover $W$ of $\vec{G}$, and a compatible total 
%order.  

The traversal algorithm, given below, will start on any given arc $e$ as the current arc.  First, it will find $e_0$.  Then, it will 
set the current arc to $e_0^{-1}$, and proceed to move around this current walk.  It will move to a new 
covering walk whenever the reverse of the current arc is the entering arc for that walk.  In this way, it simulates a Depth-First search 
of the virtual tree.  It will halt when it again reaches $e_0$.  Even though vertices and arcs of $\vec{G}$ may be visited 
multiple times, the algorithm reports each edge of $G$ exactly once. 


\begin{center}\begin{tabular*}{\textwidth}{c}\hline\end{tabular*}\end{center}
\noindent \textbf{Algorithm Walk-Traversal}$(e)$
\begin{algorithmic}[1]
  \REPEAT[find the minimum arc $e_0$]
   \STATE{$e\leftarrow \rev(e)$}
    \WHILE{$e\neq \entry(\cwalk(e))$\label{line:min}} 
      \STATE{$e\leftarrow \suc(e)$}
    \ENDWHILE 
  %\STATE{$e\leftarrow \rev(e)$}
  \UNTIL{$\ismin(e)=TRUE$}
  %\STATE{$e_0 \leftarrow e$}
  \REPEAT[start the traversal]\label{line:trav}
    \STATE{$e\leftarrow \suc(e)$ \label{line:current}}

    \IF[check to report]{$\entry(\cwalk(e))<\entry(\cwalk(\rev(e)))$}
      \STATE{\textbf{report} $e$\label{line:report}}%\label{line:}
     % \IF{$e \le \entry(\cwalk(\rev(e)))$}
       % \STATE{\textbf{report} $\tail(e)$}
     % \STATE{\textbf{report }$\tail(e)$}
    \ENDIF
%\IF{$\mintail(e)$=TRUE\label{line:rv}}
      %  \STATE{\textbf{report} $\tail(e)$}
%\ENDIF

  \IF[finished with current walk]{$e=\entry(\cwalk(e))$}
   %   \STATE{{\bf report} $\cwalk(e)$}
      \STATE{$e\leftarrow \rev(e)$\label{line:switchent}}
   \ELSE
      \IF[switch to adjacent walk]{$\rev(e)=\entry(\cwalk(\rev(e)))$}
        \STATE{$e\leftarrow \rev(e)$\label{line:switchup}}
      \ENDIF
    \ENDIF


  \UNTIL{$\ismin(e)=$TRUE}

  

\end{algorithmic}  
\begin{center}\begin{tabular*}{\textwidth}{c}\hline\end{tabular*}\end{center}


%\vspace{5mm}
Next we prove the correctness of the Walk-Traversal algorithm, as well as showing its memory and running time.  

\begin{theorem}\label{thmc}
The Walk-Traversal algorithm reports every edge of $G$ exactly once 
using $O(m \log m)$ time and 
$O(\log n)$ memory, where $G$ has $n$ vertices and $m$ edges. 
\end{theorem}

\begin{proof}

The fact that the algorithm uses $O(\log n)$ memory is clear, since every function uses no extra memory.  
First, we show that each edge and vertex is reported exactly once.  Then we prove the running time of the algorithm.  


The algorithm starts with the arc $e$ in $\vec{G}$ as input.  
First, starting on line \ref{line:min}, the algorithm searches for $e_0$ by starting with $\cwalk(e^{-1})$; if $e_0$ is not found, it moves 
to the parent walk and the search is repeated.  Lemma 
\ref{lemparent} guarantees that either $e_0$ is found, or the new entry arc is smaller than the last entry arc.  
Since $G$ is finite, this process will always halt, at which point the current arc is $e_0$.   


The main traversal starts on line \ref{line:trav}.  We know by Lemma \ref{lemtree} that 
$G(W)$ is a tree with root $\cwalk(e_0)$.  We will show that this traversal performs a depth first search of 
$G(W)$.  Initially, the current arc is $e_0$, and the current arc moves to $\suc(e_0)$, so the traversal starts in the 
root of the tree $G(W)$.  If $\cwalk(e_0)$ is the only vertex of $G(W)$, then the proof is trivial.  Otherwise 
suppose $e$ is an arc of $\vec{G}$ such that $\cwalk(e)\ne \cwalk(e_0)$, and 
let $e$ be the current arc after line \ref{line:current} has executed, and let $w=\cwalk(e)$.  If $e$ is the entering 
arc of $w$, then the current arc becomes $e^{-1}$ on line \ref{line:switchent}, which is an arc of $\parent(w)$.  
Otherwise, if $e^{-1}$ is the entering arc of $\cwalk(e^{-1})$, then the current arc becomes $e^{-1}$, which is an arc of 
the walk $w'$ such that $\parent(w)=w'$.  Hence, we can see that $G(W)$ is explored in a depth first search fashion, during 
which each arc of any given covering walk is visited.  
Furthermore, for each arc $e$, exactly one of $e$ or $e^{-1}$ is reported by line \ref{line:report}, which implies each 
edge of $G$ is reported exactly once.  


To find an upper bound on the running time of the algorithm, first ignore the computation time of the 
algorithm for testing $\entry(w)=e$.  
The running time required to find $e_0$ in the initial phase takes $O(m)$ time, since in the worst case every arc of 
$\vec{G}$ is visited.  Similarly, the 
main traversal also takes $O(m)$ time, since each arc of $\vec{G}$ is visited a constant number of times.  

Next, we must see how many times the comparison $\entry(w)=e$ is performed by the Walk-Traversal algorithm.  Since $\ismin()$ performs 
two such comparisons, we can see that for each arc $e$ of $\vec{G}$, $\entry(w)=e$ is computed at most nine times, (and hence 
18 times for each edge of $G$).  Therefore, 
by Lemma \ref{hme}, the running 
time of the Walk-Traversal algorithm is 

$O(m) +  \sum_{w\in W} 18 |w| \ln |w| = O(m\log m)$.  

 

\end{proof}

%..conjecture embedded graph application

\begin{comment}

The next section shows how to construct an oriented walk cover and a compatible total order for any geometric graph, given an embedding 
with the correct properties.

\subsection{Application to a Geometric Embedded Graph}%%%%%2

The algorithm in the previous section applies to any graph $G$ that has two structures: an oriented 
walk cover of $\vec{G}$, and a compatible total order on the arcs of $\vec{G}$.  
In this section we demonstrate that any finite graph satisfies this, provided 
it has a certain type of geometric embedding.  By embedding a graph on a surface, such that vertices do not 
coincide and arcs do not cross, we can use the faces and the coordinate system to show that a compatible 
total order and an oriented walk cover exist.

Surfaces in this section will be compact connected $2$-manifold in Euclidean $3$-space.  Non-orientable 
surfaces are not considered.  An embedding of a graph on such a surface is very similar 
to a planar embedding.

\begin{definition}
An \emph{embedding} of a graph $\vec{G}$ on a surface $\Sigma$ is a 
representation of $\vec{G}$ such that each vertex of $\vec{G}$ is associated with one point on $\Sigma$, and 
each arc in $\vec{G}$ is assocated with one simple arc on $\Sigma$ such that:
\begin{itemize}
\item The endpoints of the arc associated with the arc $e$ are associated with the respective end vertices of $e$,
\item An arc includes no points associated with any other vertices or arc interiors.
\end{itemize} 
\end{definition}


To embed the arcs of $\vec{G}$, we relax this slightly and allow $e$ and $e^{-1}$ to share interior points and 
endpoints, since they are distinguished by their directions.  
A \emph{face} of an embedded graph on a surface is an open region bounded by arcs that contains no interior vertices.  The 
set of faces can be found by taking the complement on the surface of the union of the points and arcs.
%Any finite graph can be embedded on such a surface in $\mathbb{R}^3$ of finite genus. 
Furthermore, if any vertex has non-rational 
coordinates, we can round off these values (while still requiring that vertices have distinct coordinates), 
which in effect nudges this vertex to a nearby rational point.  This technically moves the 
vertex off the surface, however we identify the same cycles in $G$ as faces of the embedding.  
For our purposes, 
the genus of the surface does not have to be minimal, 
but the embedding does have to satisfy the following property.

\begin{definition}
A \emph{2-cell embedding} is an embedding in which every face is homeomorphic to an open disk.
\end{definition}

In any $2$-cell embedding of an undirected graph $G$, each edge belongs to two faces.  In 
the same embedding of $\vec{G}$ each arc belongs to exactly one face, by orienting 
the arcs so that each face is a direced walk.  This is clearly an oriented walk cover.  Since every 
finite graph has such an embedding, (see for example \cite{MOHAR}), then every graph has this oriented walk cover.

\begin{proposition}
If $G$ is a finite graph, then $\vec{G}$ has an oriented walk cover.
\end{proposition}


From now on, suppose $G$ has an oriented walk cover $W$.  
It remains to show that $G$ has a compatible total order.  



If $u$ is a vertex of $G$, then we will denote the cartesian coordinates of 
$u$ by $( \xcor(u), \ycor(u), \zcor(u) )$.  Before we define a unique identifier 
for each arc, we must address some potential issues with these coordinates.  To this end, we will modify 
the given embedding of $G$ as follows.  For any 
$\varepsilon>0$, we can \emph{nudge} $u$ by changing its coordinates to 
$( \xcor(u)+\varepsilon, \ycor(u), \zcor(u) )$; similarly we can do this for any of the three 
coordinates of $u$.  For every edge $e=uv$ of $G$, we nudge $u$ and $v$ until all of the coordinates are nonzero rational numbers, and so 
that all three coordinates of any pair of adjacent vertices are not equal.    
Furthermore, we can chose $\varepsilon$ small enough so that the coordinates of any given vertex 
do not become unbounded.  The fact that 
this can be is evident from the density of the rational numbers in the 
real numbers.  Of course, this changes the embedding of $G$, 
such that it may no longer be embedded on the given surface, it is simply embedded in $\mathbb{R}^3$.  However, since 
we already have defined the oriented walk cover 
$W$, the surface is no longer needed, and we consider only these new coordinates of the vertices.  
%Alternately, one could consider that we are working with two embeddings, 
%one on a surface, and one that has been nudged to the above specifications.  %Either way, all we need for the following definitions 
%and theorem are the (new) coordinates of the vertices of $G$.  





We examine the geometric information of an arc using the following intermediate functions.
If $e=(u,v)$ is an 
arc of $\vec{G}$, we define three ways of measuring the slope of $e$.  Let $\sx(e)$ 
be the slope of line segment joining $u$ and $v$ after it has been projected onto the plane $x=0$; and similarly 
for $\sy(e)$ and $\sz(e)$.  Since vertices 
have been nudged above, all three of these slopes are nonzero rational numbers.  
Finally, given an arc $e=(u,v)$, we need to find out which of its 
terminal vertices is (in some sense) closer to the origin, however, it is not sufficient 
simply to compute the distance.  We say that $\closer(e)=u$ whenever 
$(\xcor(u),\ycor(u),\zcor(u)) < (\xcor(v),\ycor(v),\zcor(v))$, using lexographic comparison.  

Now we are ready to define the key, which will induce an order on the arcs.  For 
the directed arc $e=(u,v)$, we say the key of $e$ is the following nine-tuple.   

\begin{eqnarray*}
\key(e) =& &(\xcor(\closer(e)),\ycor(\closer(e)),\zcor(\closer(e)),\\
& &\sx(e),\sy(e),\sz(e),\\
& &\xcor(u),\ycor(u),\zcor(u)).
\end{eqnarray*}


Hence we define a total order on the arcs of $\vec{G}$ by letting $e<e'$ whenever $\key(e)<\key(e')$ lexographically.  We 
claim this is a compatible total order.  %For simplicity, we suppose the coordinates of all vertices are positive.  

\begin{theorem}
If $G$ is a finite graph, then the $\key$ defines a compatible total order on the arcs of $\vec{G}$.  
\end{theorem}
\begin{proof}

Clearly, the $\key$ exists for any arc.  First, we need to show distinct arcs have distinct keys.    
%Any two arcs $e$ and $e'$ two arcs are comparable.  
Let $e=(u,v)$ and $e'=(u',v')$ be distinct arcs of $\vec{G}$.  Clearly, if $u\ne u'$, then we can see by the last three coordinates 
that $\key(e)\ne \key(e')$.  Now suppose $u=u'$, which implies $v\ne v'$.  
If $\closer(e)=v$, then we are done, since $v$ and $v'$ have distinct coordinates; we obtain a similar result if $\closer(e')=v'$.  
Finally, suppose $\closer(e)=u=\closer(e')$.  So $(\xcor(u),\ycor(u),\zcor(u)) < (\xcor(v),\ycor(v),\zcor(v))$, and 
$(\xcor(u), \ycor(u), \zcor(u)) < (\xcor(v') , \ycor(v') , \zcor(v'))$, lexographically.  Suppose $\xcor(v) \ne \xcor(v')$, and now 
consider the slopes in the plane $z=0$.  If $\sz(e)\ne \sz(e')$, we are done, otherwise $\sz(e)= \sz(e')$.  This implies 
$u$ is on the line segment joining $v$ and $v'$.  Since they are not equal, we know that either $\xcor(v) < \xcor(v')$, in which case 
$\closer(e)=v$, or $\xcor(v) > \xcor(v')$, in which case $\closer(e')=v'$.  In either case, this is a contradiction.  %Hence $\xcor(v)=\xcor(v')$.  
This implies $\xcor(v') = \xcor(v')$.  Now since $v\ne v'$, we obtain a similar contradiction in one of the other two coordinates.  
We conclude that $\key(e)\ne \key(e')$.  It follows that this is a total order on the arcs of $\vec{G}$.  

It remains to show that this is a compatible total order.  Let $e=(u,v)$ be an arc such that $e < e^{-1}$.  Suppose to the contrary 
there is some arc $e'$ such that $e<e'<e^{-1}$.  Without loss of generality, let
$\closer(e)=u$, (the case for $v$ is similar).  Since $e$ and $e^{-1}$ have the same end vertices, 
$\closer(e^{-1})=u$, and $e$ and $e^{-1}$ have the same slope.  
Hence that the first six coordinates 
of $\key(e)$ and $\key(e^{-1})$ are equal  Since we supposed $e<e'<e^{-1}$, this implies 
and hence the first six coordinates $\key(e')$ are also equal to that of $e$.  Therefore $\closer(e')=u$, and $e'$ and $e$ have the same 
slope.  Since $e'$ is incident with $u$, we know that there is a vertex $x$ such that either $e'=(u,t)$ or $(t,u)$.  
If $e'=(u,t)$,  then $\key(e')=\key(e)$, which contradicts above.  Therefore $e'=(t,u)$.  
Since $\closer(e')=u$, and since $e$ and $e'$ have the same slope, they must share at leats one interior point.  This is a contradiction.    
\end{proof}





Now any finite simple graph $\vec{G}$ has an oriented walk cover and a compatible total order based on 
some simple geometric information.  Therefore the Walk-Traversal algorithm from Section \ref{ss-algorithm} 
provides graph traversal that runs in $O(m\log m)$ time and $O(\log n)$ memory.

\end{comment}

\newpage 
\section*{References}

%get all from sirocco2009, plus my own, plus all the ones for embedding chapter 1
\renewcommand*{\refname}{}
\begin{thebibliography}{9}



\bibitem{AH} S. Albers, M.R. Henzinger.  Exploring unknown environments.  \emph{SIAM J. Computing} \textbf{29} (2000) 1164--1188.

\bibitem{AKLLR} R. Aleliunas, R. Karp, R. Lipton, L. Lov\'{a}sz, C. Rackoff.  Random walks, 
universal traversal sequences, and the complexity of maxe problems.  \emph{20th Annual IEEE 
Symposium on Foundations of Computer Science}, (1979), 218--223.  %random walks logn tight o mn

\bibitem{ABRS} B. Awerbuch, M. Betke, R. Rivest, M. Sing.  Piecemeal graph exploration by 
a mobile robot.  \emph{Information and Computation} \textbf{152}(2) (1999) 155--172.  

\bibitem{BF} G. Barnes, U. Feige, Short random walks on graphs, \emph{SIAM J. Disc. Math.}, \textbf{9} (1996) 19--28.

\bibitem{BBRRT} P. Beame, A. Borodin, P. Raghavan, W. Ruzzo, M. Tompa.  A time-space tradeoff 
for undirected graph traversal for walking automata.  \emph{SIAM J. Comput.} \textbf{28}(3) (1999) 1051--1072.

\bibitem{BS} M. Bender, D.K. Slonim.  The power of team exploration: two robots can learn unlabeled directed graphs.  
\emph{35th Annual Symposium on Foundations of Computer Science (FOCS)}.  (1994) 75--85.

\bibitem{BFRSV} M. Bender, A. Fernandez, D. Ron, A. Sahai, S. Vadhan.  The power of a pebble: 
Exploring and mapping directed graphs.  \emph{Information and Computation} \textbf{176}(1) (2002) 1--21.

\bibitem{BRS} M. Betke, R. Rivest, M. Singh.  Piecemeal Learning of an Unknown Environment.  \emph{Machine Learning} 
\textbf{18} (1995) 231--254.

\bibitem{BM} P. Bose, P. Morin.  An improved algorithm for subdivision traversal without extra storage.  \emph{Internat. J. Comput. Geom. Appl.} 
\textbf{12}(4) 297--308 (2002)

\bibitem{BMSU} P. Bose, P. Morin, I. Stojmenovic, J. Urrutia.  Routing with guaranteed delivery in ad hoc wireless networks.  
\emph{Wireless Networks}, \textbf{7} (2001) 609--616.  

\bibitem{BRS} A. Blum, P. Raghavan, B. Schieber.  Navigating in unfamiliar geometric terrain.  \emph{SIAM 
Journal on Computing}, \textbf{26} (1997) 110-137.

\bibitem{BKRU} A. Broder, A. Karlin, P. Raghavan, E. Upfal.  Trading space for time in undirected $s$-$t$ connectivity.  
\emph{SIAM J. Comput.} \textbf{23} (1994) 324--334.  

\bibitem{B} L. Budach.  Automata and labyrinths.  \emph{Mathematische Nachrichten} (1978) 195--282. %applies to robot with zero pebbles

\bibitem{CDKOSU} E. Ch\'{a}vez, S. Dobrev, E. Kranakis, J. Opatrny, L. Stacho, J. Urrutia. 
Traversal of a quasi-planar subdivision without using mark bits.  \emph{Journal of Interconnection Networks} 
\textbf{5}(4) (2004).

\bibitem{CR} S. Cook, C. Rackoff.  Space lower bounds for maze threadability on restricted machines.  
\emph{SIAM J. Computing} 
\textbf{9}(3) (1980) 636--652.  

\bibitem{CELR} R. Cohen, P. Eades, T. Lin, F. Ruskey.  Three-Dimensional Graph Drawing.  \emph{Algorithmica}, 
\textbf{17} (1997) 199--208.


\bibitem{CFIKP} R. Cohen, P. Fraigniaud, D. Ilcinkas, A. Korman, D. Peleg.  Label-guided graph exploration 
by a finite automaton.  \emph{ACM Transactions on Algorithms} \textbf{4}(4) (2008) 331--344. %uses colors, no pebbles

\bibitem{BKOO} M. de Berg, M. van Kreveld, R. van Oostrum, M. Overmars.  Simple traversal of a subdivision 
without extra storage.  \emph{International Journal of Geogrpahic Information Systems},  \textbf{11} 349--373, (1997).

\bibitem{FPP} H. de Fraysseix, J. Pach, R. Pollack.  How to draw a planar graph on a grid.  \emph{Combinatorica} 
\textbf{10}(1) (1990) 41--51.

\bibitem{DKP} X. Deng, T. Kameda, C.H. Papadimitriou.  How to learn an unknown environment: The rectilinear case.  \emph{Journal 
of the ACM}, \textbf{45} (1998) 215--245.

\bibitem{DP} X. Deng, C.H. Papadimitriou.  Exploring an unknown graph.  \emph{J. Graph Theory} 
\textbf{32}(3) (1999) 265--297.

\bibitem{DJSS} S. Dobrev, J. Jansson, K. Sadakane, W.K. Sung.  Finding short 
right-hand-on-the-wall walks in graphs.  \emph{Proc. 12th Colloquium on Structural Information and 
Communication Complexity (SIROCCO)}.  \textbf{3499} (2005) 127--139.  % periodic 10n

\bibitem{DKK}  C. Duncan, S. Kobourov, V. Kumar.  Optimal constrained graph exploration.  \emph{ACM Transactions on Algorithms}, 
\textbf{2}(3) (2006) 380--402.  

\bibitem{UF} U. Fiege.  A spectrum of time-space tradeoffs for undirected $s$-$t$ connectivity.  
\emph{J. Comput. System Sci.}  \textbf{54} (1997), 305--316.  

\bibitem{FL} R. Fleischer.  The square of every two-connected graph is Hamiltonian.  \emph{Journal of Combinatorial Theory, Series B}.  
\textbf{16}(1) (1974) 29--34.

\bibitem{FT} R. Fleischer, G. Trippen.  Exploring an unknown graph efficiently.  \emph{Proc. 13th Annual 
European Symposium on Algorithms (ESA)}.  (2005) 11--22.




\%bibitem{FI} P. Fraigniaud, D. Ilcinkas.  Digraphs Exploration with Little Memory.  \emph{STACS, LNCS 2996}, (2004) 246--257.  

\bibitem{FIPPP} P. Fraigniaud, D. Ilcinkas, G. Peer, A. Pelc, D. Peleg.  Graph exploration by a finite automaton.  \emph{Theoretical 
Computer Science} \textbf{345} (2005) 331-344.  

\bibitem{F} U. Friege.  A tight upper bound on the cover time for random walks on graphs.  \emph{Random Structures and Algorithms}, 
\textbf{6}(1) 51--54 (1995).

\bibitem{GKMNZ} L. G\c{a}sieniec, R. Klasing, R. Martin, A. Navarra, X. Zhang.  Fast 
periodic graph exploration with constant memory.  \emph{J Computer and System Science}, 
\textbf{74}(5) (2008) 808--822.  

\bibitem{G} A. Georgakopoulos.  A short proof of Fleischner's theorem.  \emph{Discrete Mathematics}, \textbf{309} (2009) 6632--6634.

\bibitem{GMR} C. Gold, U. Maydell, J. Ramsden.  Automated contour mapping using triangular element data structures and an interpolant 
over each irregular triangular domain.  \emph{Computer Graphic}, \textbf{11}(2) (1997) 170--175

\bibitem{GJ} R. Gould, M, Jacobson.  Forbidden subgraphs and Hamiltonian properties in the square of a connected graph.  
\emph{Journal of Graph Theory}, \textbf{8} (1984) 147-154.

\bibitem{KSU} E. Kranakis, H. Singh, J. Urrutia.  Compas routing on geometric networks.  \emph{Proc. of 11th 
Canadian Conference on Computational Geometry}, (1999) 51--54.  

\bibitem{KWZZ} F. Kuhn, R. Wattenhoffer, Y. Zhang, A. Zollinger.  Geometric ad-hoc routing: 
Of Theory and Practice.  \emph{Proc. of the 22nd ACM Symposium on the Principles of 
Distributed Computing}, (2003).  

\bibitem{KWZ} F. Kuhn, R. Wattenhoffer, A. Zollinger.  
Worst-case optimal and average-case efficient geometric ad-hoc routing.  \emph{Proc. of the 4th ACM International 
Symposium on Mobile Ad Hoc Networking and Computing}, (2003).




\bibitem{I} D. Ilcinkas.  Setting port numbers for fast graph exploration.  \emph{Theoretical Computer Science}, 
\textbf{401} (2008) 236--242.  

\bibitem{MOHAR} B. Mohar.  Embedding graphs in an arbitrary surface in linear time.  \emph{?} \textbf{?} (1996) 392--396.  



\bibitem{PP} P. Panaite, A. Pelc.  Exploring unknown directed graphs.  \emph{Journal of Algorithms}, 
\emph{33} (1999) 281--295.

\bibitem{PM} D. Peuquet, D. Marble.  Arc/info: an example of a contemporary geographic information system.  \emph{Introductory Readings in 
Geographic Information Systems}, (1990) 90--99.

\bibitem{R} H. Rollik, Automaten in planaren graphen.  Acta Informatica \textbf{13} (1980) 287--298.  %finite number of pebbles

\bibitem{RHSI} N. Roo, S. Hareti, W. Shi, S. Iyengar.  Robot navigation in unknown terrains: Introductory survey 
of length, non-heuristic algorithms.  \emph{Techincal Report ORNL/TM12410} Oak Ridge National Lab (1993).  

\bibitem{S} C. Shannon.  Presentation of a maze-solving machine.  \emph{Proceedings of the 8th Conference 
of the Josiah Macy Jr. Foundation (Cybernetics)}.  (1951) 173--180.  %one of the first robot ex


\bibitem{T} V. Trifonov.  An $O(\log n \log \log n)$ space algorithm for undirected $st$-connectivity.  
\emph{SIAM J. Comput}, \textbf{38}(2) (2008) 449--483.  




\end{thebibliography}



















%\begin{thebibliography}{9}

%CONFERENCEARTICLE:
%\bibitem{Erdos01} P. Erd\H os, \emph{A selection of problems and
%results in combinatorics}, Recent trends in combinatorics (Matrahaza,
%1995), Cambridge Univ. Press, Cambridge, 2001, pp. 1--6.%%

%BOOK:
%\bibitem{ConcreteMath}
%R.L. Graham, D.E. Knuth, and O. Patashnik, \emph{Concrete
%mathematics}, Addison-Wesley, Reading, MA, 1989.

%JOURNAL:
%\bibitem{Knuth92} D.E. Knuth, \emph{Two notes on notation}, Amer.
%Math. Monthly \textbf{99} (1992), 403--422.

%NPUBLISHEDPAPER:
%\bibitem{Simpson} H. Simpson, \emph{Proof of the Riemann
%Hypothesis},  preprint (2003), available at 
%\url{http://www.math.drofnats.edu/riemann.ps}.

%\end{thebibliography}



 
\end{document}